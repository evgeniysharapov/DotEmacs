#+title: Emacs Configuration
#+author: Evgeniy Sharapov
#+email: evgeniy.sharapov@gmail.com


* Motivation
  As much as I liked =allout= mode it is has some quirks and irks and
  not necessarily works in the way I would like it to work. Plus, it
  has too many bells and whistles. One thing would be to have
  something like =allout-= that would reduce the complexity. However
  it is not so easy to do.

  As the size of the configuration grew and number of comments
  increased along with some notes and todo's, it seemed as a very
  logical thing to organize configuration as an Org file.


* Initialization

  =init.el= file is kept to the bare minimum - just load the
  =org-babel= and then go to the =configuration.org=.

** Benchmark
   We always want to start up as fast as possible. Hence we need to
   measure this most important KPI at the start.

   #+begin_src emacs-lisp
     (defconst *emacs-start-time* (current-time))
   #+end_src


** Paths Configuration
*** Constants for Paths

    #+begin_src emacs-lisp
      (defconst *dotfiles-dir*
        (file-name-directory (or (buffer-file-name) load-file-name))
        "Directory for dot files of Emacs configuration, i.e. path to .emacs.d directory")
      (defconst *site-lisp*
        (file-name-as-directory (concat *dotfiles-dir* "site-lisp"))
        "Directory for Emacs Extensions files")
      (defconst *elpa-dir*
        (file-name-as-directory (concat *dotfiles-dir* "elpa"))
        "Directory for ELPA packages")
      (defconst *data-dir*
        (file-name-as-directory (concat *dotfiles-dir* "data"))
        "Directory for miscellaneous data, s.a. backups, histories and caches")
      (defconst *backup-dir*
        (file-name-as-directory (concat *data-dir* "backups"))
        "Directory for backups")
      (defconst *autoload-file*
        (concat *dotfiles-dir* "loaddefs.el")
        "This is file containing all autoloads extracted from Emacs lisp files")
      (defconst *system-specific*
        (file-name-as-directory (concat *dotfiles-dir* "systems"))
        "Directory with system specific initialization commands")
    #+end_src


*** Adding Paths to =load-path=

    Adding files from =.emacs.d= to the load path

    #+begin_src emacs-lisp
      (add-to-list 'load-path *dotfiles-dir*)
    #+end_src

     Add recursively all subdirectories of =*site-lisp*=. I could have
     done it using temporary recursive function created via
     =cl-labels=. But at this point we don't have CL loaded, so I
     will do that using =fmakunbound=. The whole point is
     not to clutter function space.

     #+begin_src emacs-lisp
       ;;; create recursive function
       (defun add-directory-to-path (dir)
         (add-to-list 'load-path dir)
         (dolist (entry (directory-files-and-attributes dir))
           (if (and (cadr entry) ; t for directory
                    (not (member (car entry) '("." "..")))) ; we don't want to deal with . and ..
               (let ((new-directory (expand-file-name (car entry) dir)))
                 (add-to-list 'load-path new-directory)
                 (add-directory-to-path new-directory)))))
       ;;; add the directory tree
       (add-directory-to-path *site-lisp*)
       ;;; erase the function
       (fmakunbound #'add-directory-to-path)
     #+end_src


** Configure Package Manager
   ELPA is in between setting up paths and loading up libraries. So
   we put it right in between.
   #+begin_src emacs-lisp
     (when (require 'package nil 'noerror)
       ;; all ELPA packages are located here
       (setq package-user-dir (concat *dotfiles-dir* "elpa"))
       ;; Sources for the ELPA repositories
       (setq package-archives
             '(("gnu"         . "http://elpa.gnu.org/packages/")
               ("org"         . "http://orgmode.org/elpa/")
               ("melpa"       . "http://melpa.milkbox.net/packages/")
               ;; ("marmalade"   . "http://marmalade-repo.org/packages/")
               ))
       (package-initialize)
       (unless package-archive-contents
         (package-refresh-contents)))
   #+end_src

   This is a workaround for a bug in emacs' http fetching, see
   http://lists.gnu.org/archive/html/bug-gnu-emacs/2011-12/msg00196.html

   #+begin_src emacs-lisp
     (setq url-http-attempt-keepalives nil)
   #+end_src


** Loading Packages and Libraries
*** Loading Emacs built-in libraries
    Some of the libraries and packages that come with Emacs are so
    useful that we use them in this configuration file. Hence we will
    load them right away.

    We are trying to explicitly load as few libraries as possible.

    #+begin_src emacs-lisp
      (mapc #'require '(uniquify saveplace))
    #+end_src

    We use some of the CL functions for its convenience =cl-labels=,
    =cl-remove-if= and =cl-loop=. Hence we need to load =cl=
    library.

    #+begin_src emacs-lisp
      (require 'cl-lib)
    #+end_src

*** Loading =use-package= and =bind-key=

    We manage packages and libraries through =use-package=. So it has
    to be loaded up. However, since we have it as a Git module it may
    not be available in the freshly cloned repository. If it can't be
    loaded we should run in the command line:

    #+begin_src sh
      git submodule update --init
    #+end_src

    from the =~/.emacs.d= directory (or whatever other name could be).

   #+begin_src emacs-lisp
     (unless (require 'use-package nil 'noerror)
        (let ((default-directory (file-name-directory load-file-name)))
              (shell-command "git submodule update --init"))
        (message "Updated use-package libraries"))
     (mapc #'require '(use-package bind-key))
   #+end_src


* Key Bindings Setup
  Very useful macro to create a keymap:

  #+begin_src emacs-lisp
    (defmacro keymap-on-key (name keys)
      "This is a macro that declares a variable, key prefix and assigns a key to it.
    NAME is symbol of the new keymap and KEYS is a string that represents keys as for macro `kbd'"
      `(progn (defvar ,name)
              (define-prefix-command (quote ,name))
              (bind-key ,keys (quote ,name))))
  #+end_src

   Approach to the key binding is laid out below:

   + =C-x= primary map (some defaults)
   + =C-c= secondary map (modes use it)
   + =C-z= tertiary map =ctl-z-map= (private custom one)
     Borrowed this idea from http://www.jurta.org/en/emacs/dotemacs
     Make the prefix key =C-z= for my personal keymap.  On
     qwerty-keyboards =C-z= is one of the most accessible keys like
     =C-x= and =C-c=, but the prefix key =C-c= is reserved  for
     mode-specific commands (both user-defined and standard Emacs
     extensions). The standard binding of =C-z= (=suspend-emacs= or
     =iconify-or-deiconify-frame=) is reassigned here to double key
     sequence =C-z C-z=.
     #+begin_src emacs-lisp
       (defvar ctl-z-map)
       (define-prefix-command 'ctl-z-map)
       (let ((c-z (global-key-binding [(control ?z)])))
         (global-unset-key [(control ?z)])
         (bind-key "C-z" 'ctl-z-map)
         (bind-key "C-z C-z" c-z))
     #+end_src

   The sequence continues with quaternary, quinary, senary,
   septenary, octonary, nonary, and denary, although most of these
   terms are rarely used. There's no word relating to the number
   eleven but there is one that relates to the number twelve:
   duodenary.

   Other maps:
   + =C-x f=  - map  file operations
     #+begin_src emacs-lisp
       (keymap-on-key ctl-x-f-map "C-x f")
     #+end_src

   + =M-g=    - goto map (already exists in Emacs24)

** TODO Key Binging To Change:
   - change =M-o= from =facemenu-keymap= to =outline-mode= keymap  =M-o=

** Possible Key Bindings
   Some of the more or less possible key binding could be:
   - =C-<capital letter>=
   - =M-<capital letter>=
   - =A-<anything>=
   - =M-A-<anything>=

   Single-letter bindings still available:
   + =C- ,'";:?<>|!#$%^&*`~ <tab>=
   + =M- ?#=

   Usually following keys are easy to press with one hand
   =M-f12=, =M-f11=, =M-f10=, =M-f9=, =M-f8=, =M-f7=

** Remapping standard commands
   #+begin_src emacs-lisp :tangle yes
     ;;; almost always hit suspend instead of repeat command
     ;;; so `repeat' is both C-x z and C-x C-z
     (let ((c-x-z (global-key-binding [(control x) ?z])))
       (global-unset-key [(control x) (control ?z)])
       (define-key ctl-x-map [(control ?z)] c-x-z))
   #+end_src


* General Settings
** User Interface
   We turn off some bells and whistles and turn on some useful bits
   and pieces.

   - Turn off menu bar, scroll bars and tool bar.
     #+begin_src emacs-lisp
       (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
       (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
       (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
     #+end_src

   - File name into the frame title
     #+begin_src emacs-lisp
       (when window-system
         (setq frame-title-format '(buffer-file-name "%f" ("%b")))
         (mouse-wheel-mode t)
         (blink-cursor-mode -1))
     #+end_src

   - Display time in mode-line
     #+begin_src emacs-lisp
       (display-time)
     #+end_src

   - Hide some modes from the mode-line ( maybe this should be moved
     to the corresponding modes configuration)
     #+begin_src emacs-lisp
       (when (fboundp 'diminish)
         (eval-after-load 'eldoc
           '(diminish 'eldoc-mode)))
     #+end_src

*** Mode line configuration

    Modeline is configured using =powerline= package and =diminish=
    mode to hide information about some of the modes

    #+begin_src emacs-lisp
      (use-package diminish  :ensure t :defer t)
      (use-package powerline
        :ensure t
        :config (progn
                  (defun ffy-powerline-theme ()
                    "Powerline setup for the mode-line."
                    (interactive)
                    (setq-default mode-line-format
                                  '("%e"
                                    (:eval
                                     (let* ((active (powerline-selected-window-active))
                                            (mode-line (if active 'mode-line 'mode-line-inactive))
                                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                                            (separator-left (intern (format "powerline-%s-%s"
                                                                            powerline-default-separator
                                                                            (car powerline-default-separator-dir))))
                                            (separator-right (intern (format "powerline-%s-%s"
                                                                             powerline-default-separator
                                                                             (cdr powerline-default-separator-dir))))
                                            (lhs (list (powerline-raw "%*" nil 'l)
                                                       (powerline-buffer-size nil 'l)
                                                       (powerline-raw mode-line-mule-info nil 'l)
                                                       (powerline-buffer-id nil 'l)
                                                       (when (and (boundp 'which-func-mode) which-func-mode)
                                                         (powerline-raw which-func-format nil 'l))
                                                       (powerline-raw " ")
                                                       (funcall separator-left mode-line face1)
                                                       (when (boundp 'erc-modified-channels-object)
                                                         (powerline-raw erc-modified-channels-object face1 'l))
                                                       (powerline-major-mode face1 'l)
                                                       (powerline-process face1)
                                                       (powerline-minor-modes face1 'l)
                                                       (powerline-narrow face1 'l)
                                                       (powerline-raw " " face1)
                                                       (funcall separator-left face1 face2)
                                                       (powerline-vc face2 'r)))
                                            (rhs (list (powerline-raw global-mode-string face2 'r)
                                                       (funcall separator-left face2 face1)
                                                       (powerline-raw "%4l" face1 'l)
                                                       (powerline-raw ":" face1 'l)
                                                       (powerline-raw "%3c" face1 'r)
                                                       (funcall separator-right face1 face2)
                                                       (powerline-raw " ")
                                                       (powerline-raw "%6p" nil 'r)
                                                       (powerline-hud face2 face1))))
                                       (concat (powerline-render lhs)
                                               (powerline-fill face2 (powerline-width rhs))
                                               (powerline-render rhs)))))))
      
                 (ffy-powerline-theme)))
    #+end_src

*** Menu bar
    Turn on the menu bar for exploring new modes
    #+begin_src emacs-lisp
      (bind-key "<f1>" 'menu-bar-mode)
      (bind-key "<C-f1>" 'imenu-add-menubar-index)
    #+end_src


** Files/Directories
*** Backups and saves
    #+begin_src emacs-lisp
            (setq save-place-file (concat *data-dir* "places")
                  backup-directory-alist `((".*" . ,*backup-dir*))
                  savehist-file (concat *data-dir* "history")
                  smex-save-file (concat *data-dir* ".smex-items")
                  recentf-save-file (concat *data-dir* ".recentf")
                  ido-save-directory-list-file (concat *data-dir* ".ido.last")
                  bookmark-default-file (concat *data-dir* "bookmarks")
                  desktop-dirname *data-dir*
                  desktop-path (list desktop-dirname)
                  desktop-save t
                  auto-save-list-file-prefix (concat *data-dir* "auto-save-list/.saves-")
                  abbrev-file-name (concat *data-dir* "abbrev_defs"))
    #+end_src

    Desktop mode allows to save/open files from the previous Emacs
    session. We set the hook that would re-read Emacs desktop file at
    the end. We execute =desktop-read= in the initialization part in
    =after-init-hook= (see =init.el=).


*** URL Configuration Files
    #+begin_src emacs-lisp
      (setq url-configuration-directory (file-name-as-directory (concat *data-dir* "url")))
    #+end_src

*** Files and Projects
    #+begin_src emacs-lisp
      (use-package find-file-in-project
        :ensure t
        :commands find-file-in-project)
    #+end_src

    Opening files from =recentf= list

    #+begin_src emacs-lisp
      (defun ido-choose-from-recentf ()
        "Use ido to select a recently opened file from the `recentf-list'"
        (interactive)
        (find-file (ido-completing-read "Open file: " recentf-list nil t)))
    #+end_src


*** Files Key-Bindings

    =C-x C-f= is bound to =ido-find-file=
    =C-x f <letter>= are different file commands

    #+begin_src emacs-lisp
      (bind-key  "R"   'recentf-open-most-recent-file ctl-x-f-map)
      (bind-key  "o"   'ido-find-file-other-window    ctl-x-f-map)
      (bind-key  "f"   'find-file-in-project          ctl-x-f-map)
      (bind-key  "r"   'ido-choose-from-recentf       ctl-x-f-map)
      (bind-key  "RET" 'find-file-at-point            ctl-x-f-map)
    #+end_src

*** Dired
    Dired settings that proved useful.
    Make Dired guess where to copy files
    #+begin_src emacs-lisp
      (setq dired-dwim-target t)
    #+end_src

    Switch to "writable" =dired-mode=. It makes it very easy to rename files.
    #+begin_src emacs-lisp
      (add-hook 'dired-mode-hook
                '(lambda ()
                    (bind-key "W" 'wdired-change-to-wdired-mode dired-mode-map)))
    #+end_src


** Buffers
*** Buffer Switching

    #+begin_src emacs-lisp
      (defun ffy-display-prev-next-buffers ()
        "Show two previous, current and two next buffer names in the echo area.
      Example:
      -2:*Messages* -1:*Help*    0:.emacs      1:*info*  2:*scratch*

      From http://www.jurta.org/en/emacs/dotemacs"
        (interactive)
        (let ((i -3) b (bl (buffer-list (selected-frame))) (message-log-max nil))
          (message "%s"
                   (mapconcat
                    (lambda (x)
                      (setq i (+ i 1))
                      (format "%d:%-12s"
                              i (substring (buffer-name x) 0
                                           (min (length (buffer-name x)) 11))))
                    (append
                     (nreverse
                      (list
                       (setq b (get-next-valid-buffer (reverse bl) t))
                       (get-next-valid-buffer (cdr (memq b (reverse bl))) t)))
                     (list (current-buffer))
                     (list
                      (setq b (get-next-valid-buffer (cdr bl) t))
                      (get-next-valid-buffer (cdr (memq b bl)) t)))
                    " "))))
    #+end_src

    Show adjacent buffers in the minibuffer on switch

    #+begin_src emacs-lisp
      (defadvice previous-buffer (after my/previous-buffer activate)
        (ffy-display-prev-next-buffers))

      (defadvice next-buffer (after my/next-buffer activate)
       (ffy-display-prev-next-buffers))
    #+end_src

    Use =ibuffer= for buffer operations

    #+begin_src emacs-lisp
      (bind-key "C-x C-b" 'ibuffer)
    #+end_src

*** Mini-buffer

    Automatically close certain buffers after exiting from
    mini-buffer
    #+begin_src emacs-lisp
      (defvar *auto-close-buffers* '("*Completions*"
                                     "*Ido Completions*")
        "List of buffers that should be closed after we done with minibuffer. Usually it is various completions buffers")

      (add-hook 'minibuffer-exit-hook
                '(lambda ()
                   (progn
                     (mapc '(lambda (buffer)
                              (if (buffer-live-p buffer)
                                  (kill-buffer buffer))) *auto-close-buffers*))))
    #+end_src

    Use =smex= in the mini-buffer. =M-x= runs command and =M-X= runs
    command for the major mode.

    #+begin_src emacs-lisp
      (use-package smex
        :ensure t
        :init
        (smex-initialize)
        ;; Smex is used in minibuffer M-x
        :bind (("M-x" . smex)
               ("M-X" . smex-major-mode-commands)))
    #+end_src

    We are trying to make keys working in both Windows and Mac OS X to
    be able to =M-x= without meta

    #+begin_src emacs-lisp
      (bind-key "C-x C-m"  'execute-extended-command)
    #+end_src


*** Operations On Buffers

    #+begin_src emacs-lisp
      (bind-key "<f12>" 'kill-this-buffer)
      ;;; Buffer operations in C-z map
      (bind-key "b y" 'bury-buffer  ctl-z-map)
      (bind-key "b r" 'revert-buffer  ctl-z-map)
      ;;; revert buffer on f5
      (bind-key "<f5>" 'revert-buffer)
    #+end_src

    Other useful combos:
    - =C-x 4 0= - kill-buffer-and-window (works with current buffer
      only)
    - =C-x 4 b= - ido open buffer other window


** Windows

   Using =Windmove= for switching between windows in Emacs
   #+begin_src emacs-lisp :preamble # -*- coding: utf-8 -*-
     (windmove-default-keybindings 'super) ;; âŒ˜+direction
   #+end_src

   Moving in a window
   #+begin_src emacs-lisp
;(bind-key "t" (make-interactive move-to-window-line 0)  goto-map)
;(bind-key "b" (make-interactive move-to-window-line -1)  goto-map)
   #+end_src

*** Typical window operations but faster
(bind-key "M-0" 'delete-window)
(bind-key "M-1" 'delete-other-windows)
(bind-key "M-2" 'split-window-vertically)
(bind-key "M-3" 'split-window-horizontally)
*** Windows configurations
(define-key global-map [(control x) (super left)] 'winner-undo)
(define-key global-map [(control x) (super right)] 'winner-redo)


** Help System
   Some of the useful functions and setting dealing with Info system
   in emacs:
   #+begin_src emacs-lisp
     (require 'help-mode+ nil t)
     (require 'help+ nil t)
     (require 'help-fns+ nil t)
   #+end_src

   =apropos= seems to be more useful than =apropos-command=

   #+begin_src emacs-lisp
     (bind-key "C-h a" 'apropos)
   #+end_src


** Spell checker
   We could use Hunspell or Aspell. Hunspell seems to be better for
   spellchecking. Even though it requires building up from the
   source code it is worth it.

   First we need to make sure that Hunspell will find its
   dictionary. =find-hunspell-dictionary= works on Windows and Mac
   OS X. It finds a path to the dictionary that

   #+begin_src emacs-lisp
     (use-package s :ensure t :commands (s-lines))
     (use-package dash :ensure t :commands (-difference))

     (defun find-hunspell-dictionary ()
       "Searches for hunspell dictionaries using `hunspell -D' first and seeing if ther's
     any dictionary found. If not then try to check if dictionary exist in the same directory (case for Windows).

     On Mac OS X hunspell should search for dictionaries in at least /Library/Spelling. In fact, on Windows just drop dictionaries next to hunspell binary file.

     It returns either nil or path to the dictionary that could be used with `hunspell -d'. Put it in the `ispell-extra-args' variable.

     This function depends on 's and 'dash libraries."
       (when (executable-find "hunspell")
         ;; First, let's see if we can load any dicts by default
         (let* ((hunspell-output (shell-command-to-string "hunspell -D"))
                (hunspell-output-lines (cl-remove-if #'(lambda (e) (equal e ""))
                                                     (s-lines hunspell-output)))
                (loaded-dicts (member "LOADED DICTIONARY:"  hunspell-output-lines))
                (available-dicts (-difference (cl-member-if #'(lambda (e)(s-starts-with? "AVAILABLE DICTIONARIES" e)) hunspell-output-lines)
                                              loaded-dicts)))
           ;; If we have loaded-dicts we should be fine, otherwise try to
           ;; search for dictionaries
           (unless
               (or (cdr loaded-dicts)
                   ;; Could be a message:
                   ;; Can't open affix or dictionary files for dictionary named
                   ;; "default".
                   (not (cdr available-dicts)))
             ;; let's check if there's dictionary next to the binary
             (let ((dictionary-path (concat
                                     (file-name-directory
                                      (executable-find "hunspell")) "en_US")))
               (when (file-exists-p (concat dictionary-path ".dic"))
                 dictionary-path))))))
   #+end_src


   Setup =ispell= package
   #+begin_src emacs-lisp
     (use-package ispell
       :config (progn
                 ;; Personal dictionary setup
                 ;; if file doesn't exist then create it
                 (setq ispell-personal-dictionary (let ((personal-dictionary-file (concat *data-dir* ".personal.dict")))
                                                    (unless (file-exists-p personal-dictionary-file)
                                                      (with-temp-file personal-dictionary-file t))
                                                    personal-dictionary-file))
                 ;; Aspell Specific
                 (when (executable-find "aspell")
                   (setq ispell-program-name "aspell"
                         ispell-extra-args '("--sug-mode=ultra")))
                 ;; Hunspell Specific
                 (when (executable-find "hunspell")
                   (setq ispell-program-name "hunspell")
                   (let* ((dict-location (find-hunspell-dictionary)))
                     (when dict-location
                       (setq  ispell-extra-args '("-d" dict-location "-i" "utf-8")))))))
   #+end_src




** Miscellaneous
   Here we collect settings and commands that don't really fall into
   any specific category

   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
     (random t)
   #+end_src

** IDO settings
   IDO mode speeds up some of the tasks. Some of the IDO settings that
   have been taken out from the customization file.
   #+begin_src emacs-lisp
     (use-package ido
       :config
       (progn
         (use-package ido-ubiquitous :ensure t)
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t)

         ;; not every command should could be ido-ed
         ;; kill-ring-search has already set of minibuffer commands that don't
         ;; work well with ido-completing-read
         (setq ido-ubiquitous-command-exceptions '(kill-ring-search))

         (defun ffy--change-ido-override (behavior func-name)
           "Changes `ido-ubiquitous-function-overrides` variable for a function FUNC-NAME by setting its behavior to BEHAVIOR"
           (setq ido-ubiquitous-function-overrides
                 (mapcar (lambda (override) (if  (equal (caddr override) ,func-name)
                                           (cons ,behavior (cdr override))
                                         override))
                         ido-ubiquitous-function-overrides)))

         (defmacro enable-ido-for (func-name)
           "Enables IDO for a function using `ido-ubiquitous' mode"
           `(ffy--change-ido-override 'enable ,func-name))

         (defmacro disable-ido-for (func-name)
           "Disables IDO for a function using `ido-ubiquitous' mode"
           `(ffy--change-ido-override 'disable ,func-name))))
   #+end_src



* Editing

** Appearance
   Visual lines mode makes lines longer than window width can be
   displayed so that they are wrapped at word boundary. By default it
   is off and we want it on only for text editing modes, such as
   =latex-mode=, =markdown-mode=, etc. One can call
   =visual-line-mode= to toggle on/off.

   Visual line mode actually does several things. From a user's point
   of view, it:
   -  Makes lines wrap at word boundaries. (controlled by var
      =truncate-lines= and =word-wrap=.)
   -  Makes up/down arrow keys move by a visual line. (controlled by
      the var =line-move-visual=.)
   -  Makes the =kill-line= command delete by a visual line, as
      opposed to a logical line.
   -  Turns off the display of little return arrow at the edge of
      window. (controlled by the var =fringe-indicator-alist=.)

   #+begin_src emacs-lisp :tangle yes
     (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
   #+end_src

   Highlighting and coloring of the buffer
   #+begin_src emacs-lisp
     (use-package idle-highlight-mode :ensure t)
     (use-package rainbow-mode        :ensure t)
     (use-package rainbow-delimiters  :ensure t)
   #+end_src

   Also helpful is to highlight the current word
   #+begin_src emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :config  (progn
                  (highlight-symbol-mode +1)
                  (bind-key "<C-return>" 'highlight-symbol-at-point      ctl-z-map)
                  (bind-key "<C-up>"     'highlight-symbol-prev          ctl-z-map)
                  (bind-key "<C-down>"   'highlight-symbol-next          ctl-z-map)
                  (bind-key "@"          'highlight-symbol-query-replace ctl-z-map)))
   #+end_src

   Turn on/off showing trailing whitespace

   #+begin_src emacs-lisp
     (defun toggle-show-trailing-whitespace ()
       "Turns on/off showing of the trailing whitespaces in a current buffer"
       (interactive)
       (setq show-trailing-whitespace (not show-trailing-whitespace)))
   #+end_src


** Completions
*** Regular hippie-expand
    Naturally =hippie-expand-try-functions-list= would be made local
    variable and adjusted for a mode in the mode settings
    #+begin_src emacs-lisp
      (bind-key "M-/"  'hippie-expand)
    #+end_src

*** Auto-Complete
    Even though =auto-complete= is so widely used in Emacs world it
    has bunch of shortcomings. In particular, it uses =popup.el=
    which has issue
    [[https://github.com/auto-complete/popup-el/issues/46]]. For now I
    disabled =auto-complete= mode.

    #+begin_src emacs-lisp
      (use-package auto-complete
        :disabled t
        :ensure t
        :init (progn
                (use-package popup :ensure t)
                (use-package fuzzy :ensure t)
                (use-package auto-complete-config :ensure t)
                (use-package pos-tip :ensure t)

                ;; add our own directory to the end of the list
                (add-to-list 'ac-dictionary-directories (concat *data-dir* "ac-dict") t)
                (setq ac-comphist-file (concat *data-dir* "ac-comphist.dat"))
                (ac-config-default)
                (global-auto-complete-mode t)
                ;(setq ac-auto-show-menu t)
                ;(setq ac-dwim t)
                ;(setq ac-use-menu-map t)
                ;(setq ac-quick-help-delay 1)
                ;(setq ac-quick-help-height 60)
                ;;(setq ac-disable-inline t)
                ;(setq ac-show-menu-immediately-on-auto-complete t)
                ;(setq ac-auto-start 2)
                ;(setq ac-candidate-menu-min 0)

                (set-default 'ac-sources
                             '(
                               ac-source-abbrev
                               ac-source-imenu
                               ac-source-dictionary
                               ac-source-words-in-buffer
                               ac-source-words-in-same-mode-buffers
                               ac-source-yasnippet
                               ))

                ;; FIX: fixing issue with ac-prefix-symbol with thingatpt+
                ;; If bounds-of-thing-at-point has been redefined (and we did so)
                ;; this function will return nil.
                (defun ac-prefix-symbol ()
                  "Overriden default prefix definition function."
                  (let ((symbol-start (car-safe (bounds-of-thing-at-point 'symbol))))
                    (if (and (null symbol-start)
                             (fboundp 'tap-bounds-of-thing-nearest-point))
                        ;; try tap- function if available
                        (car-safe (tap-bounds-of-thing-nearest-point 'symbol))
                      ;; else
                      symbol-start)))))
    #+end_src

*** Company
    Due to inconveniences of the =auto-complete= package use =company=
    instead
    #+begin_src emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :config (progn
                  (setq company-idle-delay 0.2
                        company-tooltip-limit 20
                        company-show-numbers t
                        company-selection-wrap-around t
                        company-minimum-prefix-length 2
                        company-tooltip-align-annotations t
                        company-echo-delay 0))
        :init (global-company-mode 1))
    #+end_src


** Zapping

   Some of the zapping functions:

   - =zap-up-to-char= is a better alternative to regular zapping
     #+begin_src emacs-lisp
       (autoload 'zap-up-to-char "misc" "Kill up to, but not including ARGth occurrence of CHAR.
         \(fn arg char)" 'interactive)
     #+end_src

   - =zap-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-to-char-backwards (char)
           (interactive "cZap to char backwards: ")
           (zap-to-char -1 char))
     #+end_src

   - =zap-up-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-up-to-char-backwards (char)
           (interactive "cZap up to char backwards: ")
           (zap-up-to-char -1 char))
     #+end_src

  Zapping key bindings
  #+begin_src emacs-lisp
    (bind-key "C-M-z"   'zap-to-char-backwards)
    (bind-key "M-Z"     'zap-up-to-char)
    (bind-key "C-M-S-z" 'zap-up-to-char-backwards)
  #+end_src


** Kill-rings

   Searching and browsing through the =kill-ring=
   #+begin_src emacs-lisp
     (use-package browse-kill-ring
       :ensure t
       :config  (progn
                  (browse-kill-ring-default-keybindings) ; advises M-y
                  (bind-key "C-x C-y" 'browse-kill-ring)))
     (use-package kill-ring-search
       :ensure t
       :config  (progn
                  (bind-key "C-M-y" 'kill-ring-search)))
   #+end_src



** Search
*** Search in a Buffer
    #+begin_src emacs-lisp
      (bind-key "C-S-r"  'search-backward)
      (bind-key "C-S-s"  'search-forward)
    #+end_src
*** Search in Files
    #+begin_src emacs-lisp
      (use-package ack-and-a-half
        :ensure t
        :commands (ack-and-a-half ack-and-a-half-same ack-and-a-half-find-file ack-and-a-half-find-file-same)
        :init (progn
                (defalias 'ack 'ack-and-a-half)
                (defalias 'ack-same 'ack-and-a-half-same)
                (defalias 'ack-find-file 'ack-and-a-half-find-file)
                (defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)))
      (use-package grep
        :defer t
        :config
        (progn
          (setq wgrep-enable-key "e")
          (bind-key "e" 'wgrep-change-to-wgrep-mode  grep-mode-map)))
    #+end_src


** Navigation and Positioning

*** Better BOL positioning

   First define better function =ffy-bol-or-back-to-indent= to
   position either to the beginning of the line or beginning of the
   indent and switch between this two positions if necessary

     #+begin_src emacs-lisp
       (defun ffy-bol-or-back-to-indent ()
         "In addition to having two different mappings for
        (move-beginning-of-line ARG) and (back-to-indentation) we
        will have a function that goes to BOL if we are on the
        indent position and to the indent if we are at the BOL"
         (interactive)
         (if (bolp)
             (back-to-indentation)
           (move-beginning-of-line 1)))
     #+end_src

   Redefine =C-a= to =C-S-a= and =C-a to the =ffy-bol-or-back-to-indent=

   #+begin_src emacs-lisp
     (bind-key "C-S-a" (key-binding [(control ?a)]))
     (bind-key "C-a"  'ffy-bol-or-back-to-indent)
   #+end_src

*** Navigation Using Mark/Point Ring
    For better explanation see
    http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/

    Pushes mark into a ring without activating a region
    #+begin_src emacs-lisp
      (defun ffy-position-to-ring ()
        "Pushes current position to the mark-ring"
        (interactive)
        (push-mark (point) t nil)
        (message "Position %s pushed to the ring" (point)))

      (bind-key  "M-SPC" 'ffy-position-to-ring)
    #+end_src


** Marking

   Mark commands from =thing-cmds=
   #+begin_src emacs-lisp
     (use-package thing-cmds
       :ensure t
       :init (thgcmd-bind-keys))
   #+end_src


** Undo
   Undo/Redo functionality is done through =undo-tree=
   #+begin_src emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :config (global-undo-tree-mode))
   #+end_src


** Miscellaneous

   - toggles line numbers in the buffer
   #+begin_src emacs-lisp
     (bind-key "C-S-l"  'linum-mode)
   #+end_src

   - =IMenu= defaults
     #+begin_src emacs-lisp
       (set-default 'imenu-auto-rescan t)
     #+end_src

   - use =C-\= to leave one space between words
     #+begin_src emacs-lisp
       (define-key global-map [(control ?\\)] 'just-one-space)
     #+end_src

   - there's default =M-^= =delete-indentation= that is an alias to
     =join-line=
     #+begin_src emacs-lisp
       (bind-key "j" 'join-line ctl-z-map)
       (bind-key "J" (lambda () "joins next line to this one"
                                      (interactive)
                                      (join-line 1)) ctl-z-map)
     #+end_src

*** Narrowing/Widening
    Enable useful disabled Narrow/Widen commands
    #+begin_src emacs-lisp
      (dolist (command '(narrow-to-region narrow-to-defun narrow-to-page widen set-goal-column))
        (put command 'disabled nil))
    #+end_src

*** Thing At the Point
    Let's load up =thingatpt= and =thingatpt+= libraries and create
    additional functions that will change number at the point (if
    point is at the number):
    #+begin_src emacs-lisp
      (use-package thingatpt
        :defer t
        :config (progn
                  (use-package thingatpt+
                    :ensure t
                    :config (progn
                              (tap-redefine-std-fns)
                              ;; This depends on the thingatpt and thingatpt+
                              (defun ffy-tap-number-change (&optional num)
                                "Changes the number at the point by `num' passed as a prefix argument. If no argument is passed then it uses 1, i.e. decrements and increments number at the point. If it is not a number at the point, then nothing happens."
                                (interactive "p")
                                (save-excursion
                                  (let ((n (tap-number-at-point-decimal))
                                        (bounds (tap-bounds-of-number-at-point)))
                                    (if (and n bounds)
                                        (progn
                                          (delete-region (car bounds) (cdr bounds))
                                          (insert (number-to-string (+ n (or num 1)))))))))

                              (defun ffy-tap-number-decrease (&optional num)
                                "Decreases number at the point by `num' or 1 if argument is not given"
                                (interactive "p")
                                (ffy-tap-number-change (- (or num 1))))

                              (defun ffy-tap-number-increase (&optional num)
                                "Increases number at the point by `num' or 1 if argument is not given"
                                (interactive "p")
                                (ffy-tap-number-change (or num 1)))

                              (bind-key "C--"  'ffy-tap-number-decrease)
                              (bind-key "C-+"  'ffy-tap-number-increase)))))
    #+end_src

    At the end we have keys =C--= and =C-+= bound to decreasing
    number at the point and increasing number at the point.




** Snippets
   Snippets allow us to create code quickly
*** Yasnippets
    #+begin_src emacs-lisp
      (use-package yasnippet
        :ensure t
        :config
        (progn
          (use-package dropdown-list
            :ensure t)
          (add-to-list 'yas-snippet-dirs (concat *data-dir*  "snippets"))
          (yas-global-mode +1)))
    #+end_src


** Bookmarking

   #+begin_src emacs-lisp
     (use-package bm
       :ensure bm)

     (use-package bookmark
       :defer t
       :config
       (progn
         (use-package bookmark+
           :ensure t)))
   #+end_src


* Version Control Systems
** Git
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :commands magit-status
       ;; Added global shortcut to run Magit
       :bind ("C-x g" . magit-status))
   #+end_src


* Specific Modes
** Org Mode
   Org-mode is a submodule of this repository. More so I had to create a repo on bitbucket.com
   so it could be successfly cloned on any machine (via https not git protocol).

   First of all go into =site-lisp/org-mode= and run =make autoloads= and =make info=. These
   commands will create all necessary files: org-loaddefs.el and info files.

   Now Emacs should load new org-mode. 
   
   #+begin_src emacs-lisp
     (use-package org
       :ensure t
       :defer t
       :bind (("C-&" . org-mark-ring-goto)
              ("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c b" . org-iswitchb))
              ;(bind-key "C-&" 'org-mark-ring-goto  mode-specific-map) ;; due to the conflict with Yasnippet
       :init (progn
               (setq org-completion-use-ido t
                     ;; org-completion-use-iswitchb t     ; without it ido completion is
                     ;;                                   ; not going to work for
                     ;;                                   ; org-mode (see `org-read-property-value')
                     org-hide-leading-stars t
                     org-return-follows-link t
                     org-modules '(org-docview
                                   org-gnus
                                   org-id
                                   org-info
                                   org-jsinfo
                                   org-protocol
                                   org-special-blocks
                                   org-w3m
                                   org-bookmark
                                   org-elisp-symbol
                                   org-panel)
                     org-empty-line-terminates-plain-lists t
                     org-confirm-babel-evaluate nil    ; do not ask about evaluating babel
                     org-src-fontify-natively t        ; syntax highlighting
                     )
               ;; TODO: Should it be moved to a :config part ???
               (org-babel-do-load-languages
                'org-babel-load-languages
                '((dot . t)
                  (ditaa . t)
                  (emacs-lisp . t)
                  (python . t)))
     
               ;; make company completion work in Org-Mode
               (defun add-pcomplete-to-capf ()
                 (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
     
               ;(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
               (dolist (it '(turn-on-font-lock
                             yas-minor-mode-on
                             turn-on-auto-fill
                             turn-on-flyspell
                             hl-line-mode
                             add-pcomplete-to-capf
                             iimage-mode))
                       (add-hook 'org-mode-hook it)))
       :config (progn
                 ;; Override not working function from org-mode
                 (defun org-read-property-value (property)
                   "Read PROPERTY value from user."
                   (let* ((completion-ignore-case t)
                          (allowed (org-property-get-allowed-values nil property 'table))
                          (cur (org-entry-get nil property))
                          (prompt (concat property " value"
                                          (if (and cur (string-match "\\S-" cur))
                                              (concat " [" cur "]") "") ": "))
                          (set-function (org-set-property-function property))
                          (val (if allowed
                                   (funcall set-function prompt allowed nil
                                            (not (get-text-property 0 'org-unrestricted
                                                                    (caar allowed))))
                                 (funcall set-function prompt
                                          (mapcar 'list (org-property-values property))
                                          nil nil "" nil cur))))
                     (if (equal val "")
                         cur
                       val)))
                 )
     
     ;(setq org-todo-keyword-faces
     ;      (quote (("TODO" :foreground "medium blue" :weight bold)
     ;              ("NOTE" :foreground "dark violet" :weight bold)
     ;              ("STARTED" :foreground "dark orange" :weight bold)
     ;              ("WAITING" :foreground "red" :weight bold)
     ;              ("DELEGATED" :foreground "red" :weight bold))))
     
     ;(defun my-org-mode-custom-bindings ()
     ;  "customize org-mode keys"
     ;  (local-set-key [(control up)] 'outline-previous-visible-heading)
     ;  (local-set-key [(control down)]  'outline-next-visible-heading)
     ;  (local-set-key [(control meta up)]  'outline-up-heading)
     ;  (local-set-key [(control c) (meta ?w)] 'org-store-link )
     ;  (local-set-key [(control c) (control ?y)] 'org-insert-link)
     ;  (local-set-key [(control c) ?a] 'org-agenda))
     
     
     ;(dolist (mode '(org-mode))
     ;  (add-to-list 'ac-modes mode))
     
     ;;
     ;;  Setup iimage working with Org-mode
     ;;
     ;; (add-hook 'org-mode-hook 'turn-on-iimage-mode)
     
     ;; (defun org-toggle-iimage-in-org ()
     ;;   "display images in your org file"
     ;;   (interactive)
     ;;   (if (face-underline-p 'org-link)
     ;;       (set-face-underline-p 'org-link nil)
     ;;     (set-face-underline-p 'org-link t))
     ;;   (iimage-mode))
     
     
     )
   #+end_src


** Orgtbl mode
   More about orgtbl
   http://dynamic-thinking.blogspot.com/2009/11/orgtbl-mode.html
    #+begin_src emacs-lisp
      (use-package orgtbl
        :disabled t
        :commands orgtbl-mode
        :config (progn
                  (defun orgtbl-to-gfm (table params)
            "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown.
      Usage Example:
        <!--- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
        <!--- END RECEIVE ORGTBL $1 -->
        <!---
        ,#+ORGTBL: SEND $1 orgtbl-to-gfm
         | $0 |
        -->
      For more details see https://gist.github.com/grafov/8244792 and https://gist.github.com/yryozo/5807243
      "
            (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                                         org-table-last-alignment ""))
                   (params2
                    (list
                     :splice t
                     :hline (concat alignment "|")
                     :lstart "| " :lend " |" :sep " | ")))
              (orgtbl-to-generic table (org-combine-plists params2 params))))))
    #+end_src


** Markdown
   #+begin_src emacs-lisp
     (use-package markdown-mode
       :ensure t
       :config  (progn
                  (defun set-markdown-mode-outline-regexp ()
                    "Add Markdown mode specifics.  Make outline-mode navigation work for underline headers as well"
                    (make-local-variable 'outline-regexp)
                    (setq outline-regexp "#+\\|^\\(.*\\)\n\\(===+\\|---+\\)$"))

                  (add-hook 'markdown-mode-hook 'set-markdown-mode-outline-regexp)
                  (add-hook 'markdown-mode-hook 'orgtbl-mode)))
   #+end_src



** XSL/XML Editing
   #+begin_src emacs-lisp
     (defun xml-pretty-print (begin end)
       "Makes current buffer with XML markup look prettier"
       (save-excursion
         (nxml-mode)
         (goto-char begin)
         (while (search-forward-regexp "\>[ \\t]*\<" nil t) 
           (backward-char) (insert "\n"))
         (indent-region begin end))
       (message "Ah, much better!"))
     
     (defun xml-pretty-print-region (begin end)
       "Pretty format XML markup in region. You need to have nxml-mode
     http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
     this.  The function inserts linebreaks to separate tags that have
     nothing but whitespace between them.  It then indents the markup
     by using nxml's indentation rules."
       (interactive "r")
       (xml-pretty-print begin end))
     
     (defun xml-pretty-print-buffer ()
       "Formats whole buffer containing XML"
       (interactive)
       (xml-pretty-print-region (point-min) (point-max)))
     
     (setq-default
      ;; Treat elements and contents like S-expressions! Oh, the magic. 
      ;; (if you know S-expression movement commands, it's great) 
      nxml-sexp-element-flag t
       ;; Whenever you type </ it will fill out the rest. 
      nxml-slash-auto-complete-flag t)
     
     
     ;; Causes files with extensions .xml .xsl .rng .xhtml .html and .tal
     ;; to invoke nxml-mode.
     (setq auto-mode-alist 
           (cons '("\\.\\(xml\\|xsl\\|rng\\|tal\\|xsd\\|sch\\|xslt\\|svg\\|rss\\)\\'" . nxml-mode) 
                 (remove-if (lambda (x) (eq (cdr x) 'html-mode)) auto-mode-alist)))
     
     ;; another way to recognize XML files 
     (setq magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
     ;(push '("<\\?xml" . nxml-mode) magic-mode-alist)
     
     (defun ffy-customize-nxml-mode ()
       "This function sets some variables and calls some functions that setup nXML mode."
       ;; load hide show modes 
       (local-set-key "\C-c/" 'nxml-finish-element)
       (local-set-key [return] 'newline-and-indent)
       ;;(auto-fill-mode)
       (rng-validate-mode)
       (unify-8859-on-decoding-mode)
       (setq ispell-skip-html t)
       (hs-minor-mode 1)
       ;; controversial 
       (make-variable-buffer-local 'ido-use-filename-at-point)
       (setq ido-use-filename-at-point nil))
     
     (add-hook 'nxml-mode-hook 'ffy-customize-nxml-mode)
     
     (add-to-list 'hs-special-modes-alist
                  '(nxml-mode
                    "\\|<[^/>]&>\\|<[^/][^>]*[^/]>"
                    ""
                    nil))
     ;;; Add auto-complete to the the XML based modes 
     ;(dolist (mode '(nxml-mode))
     ;  (add-to-list 'ac-modes mode))
   #+end_src


** HTML and XHTML and other markup mode setup setup
   #+begin_src emacs-lisp
;; (dolist (mode '(html-mode yaml-mode  textile-mode))
;;   (add-to-list 'ac-modes mode)
   #+end_src



** TeX
   TeX editing and preview. We are using AucTeX. You can see their
   web-site for instructions.

   For installing AucTeX on Windows:
   - Download and install the pre-compiled bundle of [[http://www.gnu.org/software/auctex/download-for-windows.html][AucTeX]].
   - Unpack that archive into an Emacs directory (even though it says
     do not use pre-built thing with anything other than Emacs 24.2,
     it works with Emacs 24.3). Before you do that backup your
     ~Emacs/info/dir~ file, then compare the two (new dir and backup
     dir) and copy whatever is missing from the backed up one to the
     new one.


   Links:
   - http://cseweb.ucsd.edu/~s1pan/install_auctex.html
   - http://www.gnu.org/software/auctex/download-for-windows.html


   Another option is to install it using ELPA

   #+begin_src elisp
     (use-package auctex
       :ensure t
       :init (progn
               (load "auctex-pkg.el" nil t t)
               (load "preview.el" nil t t)))
   #+end_src


   For XeTeX use command ~M-x TeX-engine-set~


   Good viewer for PDF (and other files) on Windows is
   [[http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html][Sumatra PDF]].

   Setting up Tex previewer
   http://tex.stackexchange.com/questions/119645/emacs-auctex-view-command


*** ConTeXt specifics
    For the Context we assume that version MKiV is used. Then
    everything is run via =mtxrun= or =context= commands.

    


** General Programming
   Most of the setup here will benefit any programming language mode.

   #+begin_src emacs-lisp
     (autoload 'turn-on-fic-mode "fic-mode")

     (defun local-column-number-mode ()
       (make-local-variable 'column-number-mode)
       (column-number-mode t))

     (defun local-comment-auto-fill ()
       (set (make-local-variable 'comment-auto-fill-only-comments) t)
       (auto-fill-mode t))

     (defun turn-on-hl-line-mode ()
       (if window-system (hl-line-mode t)))

     (defun turn-on-whitespace ()
       (whitespace-mode t))

     (defun turn-on-flyspell-prog-mode ()
       (when (and (boundp 'ispell-program-name)
                  (executable-find ispell-program-name))
         (flyspell-prog-mode)))
   #+end_src

*** Flymake and Syntax checking
    #+begin_src emacs-lisp
      (use-package flymake
        :init (progn
                (use-package flymake-cursor  :ensure t)
                (defun turn-on-flymake ()
                  (flymake-mode))))
    #+end_src


*** Electric and Autopairs
    #+begin_src emacs-lisp
      (defun turn-on-electric-mode ()
        (electric-pair-mode +1))
    #+end_src


*** Programming Modes

    Add following functions to the programming modes hooks
    - =local-column-number-mode=
    - =local-comment-auto-fill=
    - =turn-on-hl-line-mode=
    - =pretty-greek= this one is added below
    - =turn-on-fic-mode=
    - =turn-on-flyspell-prog-mode=
    - =turn-on-flymake=

   Pretty Greek functions replaces words like _lambda_ and _alpha_
   with grek symbols
   #+begin_src emacs-lisp
     (defun pretty-greek ()
       (let ((greek '("alpha" "beta" "gamma" "delta" "epsilon" "zeta" "eta" "theta" "iota" "kappa" "lambda" "mu" "nu" "xi" "omicron" "pi" "rho" "sigma_final" "sigma" "tau" "upsilon" "phi" "chi" "psi" "omega")))
         (loop for word in greek for code = 97 then (+ 1 code) do
               (let ((greek-char (make-char 'greek-iso8859-7 code)))
                 (font-lock-add-keywords
                  nil
                  `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[a-zA-Z]")
                     (0
                      (progn
                        (decompose-region (match-beginning 2)
                                          (match-end 2))
                        nil)))))
                 (font-lock-add-keywords
                  nil
                  `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[^a-zA-Z]")
                     (0
                      (progn
                        (compose-region (match-beginning 2)
                                        (match-end 2) ,greek-char)
                        nil)))))))))
   #+end_src

*** Global tags
    Make sure GNU Global is installed. Mac has port for that and binaries
    for Windows are [[http://adoxa.altervista.org/global/][here]]
    #+begin_src emacs-lisp
      (use-package ggtags
        :ensure t
        :init (progn
                (defun turn-on-ggtags-mode ()
                  (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                    (ggtags-mode 1)))
      
                (add-hook 'c-mode-common-hook 'turn-on-ggtags-mode)))
    #+end_src

** Paredit
   Nice mode for dealing with all those parentheses in lisp modes
   #+begin_src emacs-lisp
     (use-package paredit
       :ensure t
       :diminish paredit-mode
       :config (progn
                 (defun ffy-paredit-forward-delete ()
                   "Forces deleting a character in ParEdit mode"
                   (paredit-forward-delete +1))
     
                 (bind-key "C-S-d" 'ffy-paredit-forward-delete  paredit-mode-map)
     
                 (defun ffy-init-lisp-minibuffer-enable-paredit-mode ()
                   "Enable function `paredit-mode' during `eval-expression'. Adding `paredit-mode' for an `eval-expression' in minibuffer. RET  works as an exit minibuffer with evaluation."
                   (if (eq this-command 'eval-expression)
                       (when (fboundp 'paredit-mode)
                         (paredit-mode +1))))
                 ;; this will enable paredit in mini-buffer
                 (add-hook 'minibuffer-setup-hook 'ffy-init-lisp-minibuffer-enable-paredit-mode)))
   #+end_src


** Emacs Lisp
   Modes that deal with Emacs-Lisp
   #+begin_src emacs-lisp
     (defconst *emacs-lisp-modes* '(emacs-lisp-mode lisp-mode ielm-mode))
   #+end_src

   SLIME-like navigation in emacs
   #+begin_src emacs-lisp
     (use-package elisp-slime-nav
       :ensure t
       :diminish elisp-slime-nav-mode
       :init (progn
               (defun turn-on-elisp-slime-nav-mode ()
                 "Turns SLIME style navigation on in Emacs-lisp."
                 (elisp-slime-nav-mode 1))))
   #+end_src

   Add Emacs-Lisp specific completions and navigation mode to the
   setup of Emacs-Lisp modes

   #+begin_src emacs-lisp
     (defun ffy-init-emacs-lisp-modes ()
       "Only emacs-lisp related things."
       (progn
         (make-local-variable 'hippie-expand-try-functions-list)
         (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol 'to-the-end)
         (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol-partially 'to-the-end)
         (when (fboundp 'highlight-parentheses-mode)
           (highlight-parentheses-mode +1))
         (bind-key "<M-return>" 'reindent-then-newline-and-indent  lisp-mode-shared-map)
         (bind-key "C-x x" 'eval-print-last-sexp  lisp-mode-shared-map)))
     
     (dolist (mode *emacs-lisp-modes*)
       (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
         (mapc (apply-partially 'add-hook mode-hook)
               '(ffy-init-emacs-lisp-modes
                 local-column-number-mode
                 local-comment-auto-fill
                 turn-on-hl-line-mode
                 turn-on-fic-mode
                 turn-on-flyspell-prog-mode
                 turn-on-flymake
                 enable-paredit-mode
                 turn-on-elisp-slime-nav-mode
                 turn-on-eldoc-mode
                 rainbow-delimiters-mode-enable))))
   #+end_src

*** IELM - Emacs Lisp Interpreter
    Interpreter of Emacs-Lisp running in Emacs. Very helpful if we
    want run some command or change settings or instrument
    major/minor mode of the buffer we currently working on

    We want to indent if we press =RET= while inside of the
    S-expression and execute it if we are at the end.

    #+begin_src emacs-lisp
      (defun ffy-ielm-return ()
        "Like `ielm-return' but more intellectual when it comes to deciding when just
      send `paredit-newline' instead.
      Implementation shamelessly stolen from: https://github.com/jwiegley/dot-emacs/blob/master/init.el"
        (interactive)
        (let ((end-of-sexp (save-excursion
                                 (goto-char (point-max))
                                 (skip-chars-backward " \t\n\r")
                                 (point))))
              (if (>= (point) end-of-sexp)
                  (progn
                    (goto-char (point-max))
                    (skip-chars-backward " \t\n\r")
                    (delete-region (point) (point-max))
                    (call-interactively #'ielm-return))
                (call-interactively #'paredit-newline))))
    #+end_src

    Hook =ffy-ielm-return= onto the =RET= key

    #+begin_src emacs-lisp
      (defun ffy-setup-ielm ()
        "Sets some IELM defaults and keys."
        (interactive)
        (progn
          (local-set-key [return] 'ffy-ielm-return)))
    #+end_src

    And add it to the  IELM setup hook
    #+begin_src emacs-lisp
      (add-hook 'ielm-mode-hook 'ffy-setup-ielm)
    #+end_src


    We want to start new IELM session with the current buffer only if
    we don't have IELM running. If we do, we just want to switch to
    IELM instead

    #+begin_src emacs-lisp
      (defun ffy-ielm ()
        "Starts IELM or switches to existing one in the new window and sets working buffer of IELM to the current buffer."
        (interactive)
        (let ((buf (current-buffer)))
          (if (get-buffer "*ielm*")
              (switch-to-buffer-other-window "*ielm*")
            (progn
              (split-window-sensibly (selected-window))
              (other-window 1)
              (ielm)))
          (ielm-change-working-buffer buf)))
    #+end_src

    Press =C-c M-:= to start IELM with current buffer
    #+begin_src emacs-lisp
      (bind-key "C-c M-:" 'ffy-ielm)
    #+end_src

    Completion in IELM buffer (added Auto-Complete, but now use
    Company mode which is global)
    #+begin_src emacs-lisp
;(dolist (mode '(inferior-emacs-lisp-mode))
;  (add-to-list 'ac-modes mode))
    #+end_src



** Clojure

   #+begin_src emacs-lisp
     (defun ffy-find-file-in-clojure-project ()
       "For Clojure we are also looking for project.clj file in the project root"
       (progn
         (require 'find-file-in-project)
         (when (boundp 'ffip-project-file)
           (set (make-local-variable 'ffip-project-file)
                (if (listp 'ffip-project-file)
                    (cons "project.clj" ffip-project-file)
                  (list "project.clj" ffip-project-file))))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package clojure-mode
       :ensure t
       :defer t
       :init (progn
               (use-package clojure-test-mode :ensure t :defer t)
               (use-package cider
                 :ensure t
                 :defer t
                 :config (progn
                           (use-package company-cider :ensure t :defer t)))
               (mapc (apply-partially 'add-hook 'clojure-mode-hook)
                     '(ffy-find-file-in-clojure-project
                       subword-mode
                       clojure-test-mode
                       enable-paredit-mode
                       turn-on-hl-line-mode
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       turn-on-flymake
                       local-column-number-mode
                       local-comment-auto-fill
                       turn-on-eldoc-mode
                       rainbow-delimiters-mode-enable))
               ;; TODO: add this to the :bind directive
               (bind-key "<M-return>" 'reindent-then-newline-and-indent  lisp-mode-shared-map)
               (bind-key "C-x x" 'eval-print-last-sexp  lisp-mode-shared-map)))
   #+end_src


** Ruby/Rails setup
   Loading  Ruby and Rails relate ELPA packages
   #+begin_src emacs-lisp
     (use-package ruby-mode
       :ensure t
       :init (progn
               (use-package rinari
                 :ensure t
                 :config
                 (global-rinari-mode 1))
               (use-package rspec-mode :ensure t)
               (use-package ruby-compilation :ensure t)
               (use-package ruby-electric :ensure t)
               (use-package ruby-end
                 :ensure t
                 :config (progn
                           (defalias 'ruby-insert-end 'ruby-end-insert-end)))
               (use-package rvm :ensure t)
               (use-package yari :ensure t)
               (use-package flymake-ruby :ensure t)
     
               (defun ffy-insert-ruby-string-interpolation ()
                 "In a double quoted string, interpolation is inserted on #."
                 (interactive)
                 (insert "#")
                 (when (and
                        (looking-back "\".*")
                        (looking-at ".*\""))
                   (insert "{}")
                   (backward-char 1)))
               )
       :config (progn
                 (bind-key "<return>" 'reindent-then-newline-and-indent ruby-mode-map)
                 (bind-key "#" 'ffy-insert-ruby-string-interpolation  ruby-mode-map)
                 (bind-key "C-h r" 'yari  ruby-mode-map)
                 (mapc (apply-partially 'add-hook 'ruby-mode-hook)
                       '(subword-mode
                         ruby-electric-mode
                         local-column-number-mode
                         local-comment-auto-fill
                         turn-on-hl-line-mode
                         turn-on-fic-mode
                         turn-on-flyspell-prog-mode
                         turn-on-flymake
                         flymake-ruby-load
                         inf-ruby-minor-mode)))
       :mode (("\\.rb$" . ruby-mode)
              ("\\.rake$" . ruby-mode)
              ("\\.gemspec$" . ruby-mode)
              ("\\.ru$" . ruby-mode)
              ("Rakefile$" . ruby-mode)
              ("Gemfile$" . ruby-mode)
              ("Capfile$" . ruby-mode)
              ("Guardfile$" . ruby-mode)))
   #+end_src


** YAML
   This is closely related to Ruby/Rails
   #+begin_src emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode (("\\.ya?ml$" . yaml-mode)))
   #+end_src



** HAML/SCSS/SASS setup
   Closely related to Ruby/Rails development

   #+begin_src emacs-lisp
     (use-package haml-mode
       :ensure t
       :commands haml-mode
       :mode ("\\.haml$" . haml-mode)
       :init (progn
               (use-package flymake-haml
                 :ensure t
                 :defer t
                 :config (progn
                           (add-hook 'haml-mode-hook 'flymake-haml-load)))))
     ;;; custom line opening
     (defun ffy-open-line-indented (n)
       "like `open-line' but keeps indentation"
       (interactive "*p")
       (let* ((loc (point-marker)))
         (newline-and-indent)
         (goto-char loc)))

     (use-package scss-mode
       :ensure t
       :defer t
       :commands scss-mode
       :mode ("\\.scss$" . scss-mode)
       :init (progn
               ;; my own customizations
               (defun ffy-customize-sass-scss-mode ()
                 (interactive)
                 ;; first of all <ret> sets newline and indent as C-j
                 (local-set-key [return] 'newline-and-indent)
                 (local-set-key [(control return)] 'ffy-open-line-indented))
               (use-package sass-mode
                 :ensure t
                 :defer t
                 :commands sass-mode
                 :mode ("\\.sass$" . sass-mode)
                 :config (progn
                           (mapc (apply-partially 'add-hook 'sass-mode-hook)
                                 '(local-column-number-mode
                                   local-comment-auto-fill
                                   turn-on-hl-line-mode
                                   turn-on-fic-mode
                                   turn-on-flyspell-prog-mode
                                   turn-on-flymake
                                   ffy-customize-sass-scss-mode))))
               (use-package flymake-sass
                 :ensure t
                 :defer t
                 :config (progn
                           (add-hook 'scss-mode-hook 'flymake-sass-load)
                           (add-hook 'sass-mode-hook 'flymake-sass-load)))
               (mapc (apply-partially 'add-hook 'scss-mode-hook)
                     '(local-column-number-mode
                       local-comment-auto-fill
                       turn-on-hl-line-mode
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       turn-on-flymake
                       ffy-customize-sass-scss-mode))))

     ;;; add Auto-Complete HAML SCSS and SASS modes
     ;(dolist (mode '(haml-mode sass-mode scss-mode))
     ;  (add-to-list 'ac-modes mode))
   #+end_src


** Coffee-Script
   #+begin_src emacs-lisp
     (use-package coffee-mode
       :ensure t
       :defer t
       :commands coffee-mode
       :mode ("\\.coffee$" . coffee-mode)
       :config (progn
                 (use-package flymake-coffee
                   :ensure t
                   :config (progn
                             (add-hook 'coffee-mode-hook 'flymake-coffee-load)))))
   #+end_src


** JavaScript
   Good link about setting up Javascript:
   - [[http://blog.deadpansincerity.com/2011/05/setting-up-emacs-as-a-javascript-editing-environment-for-fun-and-profit/][Setup Emacs as a JavaScript IDE For Fun and Profit]]

*** Rhino
**** Setup Rhino
       - On Windows:
         + Download rhino1_7R4.zip from Mozilla page.
         + Unpack it and copy js.jar to =%JRE_HOME%\lib\ext=

       - On Mac OS X:
         + Download rhino and unzip it
         + Make a the library directory if it doesn't exist:
           #+begin_example
            mkdir -p ~/Library/Java/Extensions
           #+end_example

         + Copy the jar to the extensions directory:
           #+begin_example
            cp ~/Downloads/rhino1_7R2/js.jar ~/Library/Java/Extensions/
           #+end_example

**** Running Rhino

     Run the following command:
     #+begin_example
       java org.mozilla.javascript.tools.shell.Main
     #+end_example


*** Setup Emacs

    Make sure =node.js= and =npm= are installed.

    Install =jshint=, =jslint= and =tern= using =npm=

   #+begin_src emacs-lisp
     (use-package js2-mode
       :ensure t
       :diminish (js2-minor-mode . "JS2")
       :init  (progn
                (use-package js-comint
                  :ensure t
                  :config (progn
                            ;; Use NodeJS as our repl if it is available
                            ;; otherwise stick to the Rhino
                            (let* ((node-program (executable-find "node"))
                                   (node-command (if node-program (concat node-program " --interactive")))
                                   (js-command  (or node-command "java org.mozilla.javascript.tools.shell.Main")))
                              (setq inferior-js-program-command js-command))))

                (use-package flymake-jslint :ensure t)
                (use-package flymake-jshint :ensure t)
                (use-package ac-js2 :ensure t)
                (use-package js2-imenu-extras
                  :config (js2-imenu-extras-setup))

                ;; TODO: Add Swank-js
                ;; http://www.idryman.org/blog/2013/03/23/installing-swank-dot-js/
                ;; Install Swank.js by
                ;;     npm install -g swank-js
                ;; Test by running
                ;;     swank-js
                ;; And directing browser to http://localhost:8009/swank-js/test.html

                (defun ffy-js-mode-customizations ()
                  "JavaScript customizations"
                  ;; Scan the file for nested code blocks
                  (imenu-add-menubar-index)
                  ;; Activate the folding mode
                  (hs-minor-mode t))

                (add-to-list 'interpreter-mode-alist '("node" . js-mode))
                (add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
                (add-to-list 'auto-mode-alist '("\\.json$" . js-mode)))

       :config (progn
                 (add-hook 'js-mode-hook 'ffy-js-mode-customizations)
                 (add-hook 'js-mode-hook 'js2-minor-mode)
                 (add-hook 'js-mode-hook 'turn-on-electric-mode)
                 (add-hook 'js-mode-hook 'turn-on-flymake)
                 (add-hook 'js2-mode-hook 'ac-js2-mode)
                 (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)

                 ;;; Add Auto-Complete to JavaScript modes.
                 ;(dolist (mode '(espresso-mode js-mode js2-minor-mode js2-mode))
                 ;  (add-to-list 'ac-modes mode))
     ))
   #+end_src

   Good package for remote debugging in the browser is =jss=. Read
   more at https://github.com/segv/jss
   #+begin_src emacs-lisp
     (use-package jss
       :ensure t
       :defer t)
   #+end_src

   Some things I haven't got to yet
   #+begin_src emacs-lisp
     ;; (setq inferior-js-mode-hook
     ;;       (lambda ()
     ;;         ;; We like nice colors
     ;;         (ansi-color-for-comint-mode-on)
     ;;         ;; Deal with some prompt nonsense
     ;;         (add-to-list
     ;;          'comint-preoutput-filter-functions
     ;;          (lambda (output)
     ;;            (replace-regexp-in-string "\033\\[[0-9]+[GK]" "" output)))))
     
     ;; (setq inferior-js-mode-hook
     ;;       (lambda ()
     ;;         ;; We like nice colors
     ;;         (ansi-color-for-comint-mode-on)
     ;;         ;; Deal with some prompt nonsense
     ;;         (add-to-list 'comint-preoutput-filter-functions
     ;;                      (lambda (output)
     ;;                        (replace-regexp-in-string ".*1G\.\.\..*5G" "..."
     ;;                      (replace-regexp-in-string ".*1G.*3G" "&gt;" output))))
   #+end_src


** Octave Mode
   #+begin_src emacs-lisp
     (setq auto-mode-alist
           (cons '("\\.m$" . octave-mode) auto-mode-alist))
     (add-hook 'octave-mode-hook (lambda ()
                                   (auto-fill-mode 1)))
   #+end_src


** Haskell Mode

   The easiest way to start with Haskell is to install Haskell
   Platform. The caveat here is that GHC is a little bit old.

   #+begin_src emacs-lisp
     (use-package haskell-mode
       :ensure t
       :init (progn
               (mapc (apply-partially 'add-hook 'haskell-mode-hook)
                     '(local-column-number-mode
                       local-comment-auto-fill
                       turn-on-hl-line-mode
                       pretty-greek
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       ;; turn-on-flymake
                       turn-on-haskell-doc-mode
                       ;; turn-on-haskell-indent
                       turn-on-haskell-indentation
                       interactive-haskell-mode))))
   #+end_src

   To provide navigation to definitions we need to install =hasktags=
   via =cabal install hasktags= into a global.

   #+begin_src emacs-lisp
     (when (executable-find "hasktags")
       (custom-set-variables
        '(haskell-tags-on-save t)))
   #+end_src

   To provide addition functionality we install =ghc-mod= package
   using cabal, if it is not installed yet =cabal install ghc-mod=.

   If you use GHC version 7.8 and later, then chances are you have
   some of the functionality already there (such as =:complete=)

   For auto-completion there's a package =company-ghc=
   (https://github.com/iquiw/company-ghc). It will also install =ghc=
   package as a dependency

   #+begin_src emacs-lisp
     (use-package company-ghc
       :ensure t
       :init (progn
               ;; add as a company back-end
               (add-to-list 'company-backends 'company-ghc)
               (add-hook 'haskell-mode-hook 'ghc-init)))
   #+end_src

   More details on =ghc-mod= and emacs =ghc= package are available at
   http://www.mew.org/~kazu/proj/ghc-mod/en/

   Interesting configurations to look at:
   - https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el
   - https://github.com/serras/emacs-config-2/blob/master/haskell.el

   Configuration tutorial at
   https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

   
   Keys:
   - =M-RET= add import
   - =M-t= add signature to the function missing it.

   
*** GHCi

    Interpreter in haskell is available at =C-c C-l= but only in
    Cabal projects.

    Install =hoogle= package to search for the Haskell code and
    documentation in the libraries.

    Installing hoogle on Mac OS X with GHC 7.6.3 (the one from
    Haskell Platform ) will most likely fail due to the bug in
    compiler. It manifests itself as an error while installing
    =conduit= package (error itself described here :
    https://github.com/snoyberg/conduit/issues/147 ). To fix it one
    needs to put a wrapper for llvm preprocessor. Details are here
http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9.
    However binary wrapper is not available anymore. To fix it using
    bash script go here: https://www.haskell.org/platform/mac.html
    In short, it will patch haskell platfor (settings file) to make
    it work with clang.

    After installing =hoogle=, add call to hoogle to ghci (see
    http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration).

    If command line works then it will also work =haskell-mode=,
    check variable =haskell-hoogle-command=


** Python
   On Mac to use Python one should use MacPorts then one could see
   available pythons via =port select --list python=. To activate
   python use =sudo port select --set python python27=. Install =pip=
   using MacPorts, =sudo port install py-pip=. If installation fails
   run =clean= command and repeat. It should install =pip= for
   appropriate version of Python (the one that has been activated).

   When =pip= is installed using =get-pip.py= script it fails to
   install some packages, probably because of missing deps.





** C/C++

   Writing C/C++ programs.
   Good source of information [[http://tuhdo.github.io/c-ide.html]]

   #+begin_src emacs-lisp
     (use-package cc-mode
       :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
              ("\\.m\\'"                   . c-mode)
              ("\\.mm\\'"                  . c++-mode))
       )
   #+end_src

   Using =company-c-headers=. By default, it adds only C headers.
   Adding C++ paths needs to be manual and system dependent. In its
   easiest form figuring out what are the paths is as easy as =g++
   -v=. More information about preprocessors paths could be found at
   https://gcc.gnu.org/ml/gcc-help/2007-09/msg00206.html

   On Mac OS X after 10.8 =g++= is actually a =clang=.
   Another way is =cpp -Wp -v=

   #+begin_src emacs-lisp :tangle yes
     (use-package company-c-headers
       :ensure t
       :config (progn
                 (add-to-list 'company-backends 'company-c-headers)
                 (add-to-list 'company-c-headers-path-system "/usr/include/c++/4.2.1")))
   #+end_src
   

* Finally

  Load custom variables and faces from the customization file
  #+begin_src emacs-lisp
    (setq custom-file (concat *dotfiles-dir* "custom.el"))
    (load custom-file 'noerror)
  #+end_src

  Each workstation I work on has some specific details that are
  described in the file for that machine. They are stored in the
  machine specific folder =systems=. Loading machine specific settings:

  #+begin_src emacs-lisp
    (let ((system-specific-config (concat *system-specific* system-name ".el")))
      (if (file-exists-p system-specific-config)
          (load system-specific-config)))
  #+end_src

  How long did it take to load?

  #+begin_src emacs-lisp
    (let ((elapsed (float-time (time-subtract (current-time)  *emacs-start-time*))))
      (message "Loading Emacs...done (%.3fs)" elapsed))
  #+end_src
