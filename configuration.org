#+title: Emacs Configuration
#+author: Evgeniy Sharapov
#+email: evgeniy.sharapov@gmail.com


* Motivation
  As much as I liked =allout= mode it is has some quirks and irks and
  not necessarily works in the way I would like it to work. Plus, it
  has too many bells and whistles. One thing would be to have
  something like =allout-= that would reduce the complexity. However
  it is not so easy to do.

  As the size of the configuration grew and number of comments
  increased along with some notes and todo's, it seemed as a very
  logical thing to organize configuration as an Org file.


* Initialization
  =init.el= file is kept to the bare minimum - just load the
  =org-babel= and then go to the =configuration.org=.

  By default all =src= blocks with Emacs Lisp are _tangled_. That is
  all of them will go into =configuration.el= file that gets loaded.
  One can turn off a particular bit by adding =:tangle no= to an =src=
  block header. Or setting a property for  a whole subtree. For
  instance by pressing =C-c C-x p= or by calling =org-set-property=.

** Benchmark
   We always want to start up as fast as possible. Hence we need to
   measure this most important KPI at the start.

   #+begin_src emacs-lisp
     (defconst *emacs-start-time* (current-time))
   #+end_src


** Paths Configuration
*** Constants for Paths

    #+begin_src emacs-lisp
      (defconst *dotfiles-dir*
        (file-name-directory (or (buffer-file-name) load-file-name))
        "Directory for dot files of Emacs configuration, i.e. path to .emacs.d directory")
      (defconst *site-lisp*
        (file-name-as-directory (concat *dotfiles-dir* "site-lisp"))
        "Directory for Emacs Extensions files")
      (defconst *elpa-dir*
        (file-name-as-directory (concat *dotfiles-dir* "elpa"))
        "Directory for ELPA packages")
      (defconst *data-dir*
        (file-name-as-directory (concat *dotfiles-dir* "data"))
        "Directory for miscellaneous data, s.a. backups, histories and caches")
      (defconst *backup-dir*
        (file-name-as-directory (concat *data-dir* "backups"))
        "Directory for backups")
      (defconst *autoload-file*
        (concat *dotfiles-dir* "loaddefs.el")
        "This is file containing all autoloads extracted from Emacs lisp files")
      (defconst *system-specific*
        (file-name-as-directory (concat *dotfiles-dir* "systems"))
        "Directory with system specific initialization commands")
    #+end_src


*** Adding Paths to =load-path=

    Adding files from =.emacs.d= to the load path

    #+begin_src emacs-lisp
      ;; (add-to-list 'load-path *dotfiles-dir*)
    #+end_src

     Add recursively all subdirectories of =*site-lisp*=. I could have
     done it using temporary recursive function created via
     =cl-labels=. But at this point we don't have CL loaded, so I
     will do that using =fmakunbound=. The whole point is
     not to clutter function space.

     #+begin_src emacs-lisp
       ;;; create recursive function
       (defun add-directory-to-path (dir)
         (add-to-list 'load-path dir)
         (dolist (entry (directory-files-and-attributes dir))
           (if (and (cadr entry) ; t for directory
                    (not (member (car entry) '("." "..")))) ; we don't want to deal with . and ..
               (let ((new-directory (expand-file-name (car entry) dir)))
                 (add-to-list 'load-path new-directory)
                 (add-directory-to-path new-directory)))))
       ;;; add the directory tree
       (add-directory-to-path *site-lisp*)
       ;;; erase the function
       (fmakunbound #'add-directory-to-path)
     #+end_src


** Configure Package Manager
   ELPA is in between setting up paths and loading up libraries. So
   we put it right in between.
   #+begin_src emacs-lisp
     (when (require 'package nil 'noerror)
       ;; all ELPA packages are located here
       (setq package-user-dir (concat *dotfiles-dir* "elpa"))
       ;; Sources for the ELPA repositories
       (mapc (apply-partially 'add-to-list 'package-archives)
             '(
               ;; ("gnu"         . "http://elpa.gnu.org/packages/")
               ;; ("org"         . "http://orgmode.org/elpa/")
               ("melpa-stable" . "http://stable.melpa.org/packages/")
               ("melpa"       . "http://melpa.org/packages/")
               ;;("marmalade"   . "http://marmalade-repo.org/packages/")
              ))
       (package-initialize)
       (unless package-archive-contents
         (package-refresh-contents)))
   #+end_src

   We want to filter particular packages. For that use
   ='package-pinned-package=

   #+begin_src emacs-lisp
     (mapc (lambda (arg) (apply (apply-partially 'add-to-list 'package-pinned-packages) arg))
           '(
             ;; if t at the end then append it, otherwise prepend
             ((cider . "melpa-stable") t)
             ((flycheck . "melpa-stable"))
             ))
   #+end_src

   This is a workaround for a bug in emacs' http fetching, see
   http://lists.gnu.org/archive/html/bug-gnu-emacs/2011-12/msg00196.html

   #+begin_src emacs-lisp
     (setq url-http-attempt-keepalives nil)
   #+end_src


** Loading Packages and Libraries
*** Loading Emacs built-in libraries
    Some of the libraries and packages that come with Emacs are so
    useful that we use them in this configuration file. Hence we will
    load them right away.

    We are trying to explicitly load as few libraries as possible.

    #+begin_src emacs-lisp
      (mapc #'require '(uniquify saveplace))
    #+end_src

    We use some of the CL functions for its convenience =cl-labels=,
    =cl-remove-if= and =cl-loop=. Hence we need to load =cl=
    library.

    #+begin_src emacs-lisp
      (require 'cl-lib)
    #+end_src

*** Loading =use-package= and =bind-key=

    We manage packages and libraries through =use-package=. So it has
    to be loaded up. However, since we have it as a Git module it may
    not be available in the freshly cloned repository. If it can't be
    loaded we should run in the command line:

    #+begin_src sh
      git submodule update --init
    #+end_src

    from the =~/.emacs.d= directory (or whatever other name could be).

   #+begin_src emacs-lisp
     (unless (require 'use-package nil 'noerror)
        (let ((default-directory (file-name-directory load-file-name)))
              (shell-command "git submodule update --init"))
        (message "Updated use-package libraries"))
     (mapc #'require '(use-package bind-key))
   #+end_src


** Some Windows Specific
   Make sure that you have following DLL libraries in you =Emacs/bin=
   directory:
   - libcharset.dll
   - libiconv.dll
   - libxml2.dll
   - libXpm.dll
   - zlib1.dll

  You can download them from: http://xmlsoft.org/sources/win32/64bit/

* Key Bindings Setup
  Very useful macro to create a keymap:

  #+begin_src emacs-lisp
    (defmacro keymap-on-key (name keys)
      "This is a macro that declares a variable, key prefix and assigns a key to it.
    NAME is symbol of the new keymap and KEYS is a string that represents keys as for macro `kbd'"
      `(progn (defvar ,name)
              (define-prefix-command (quote ,name))
              (bind-key ,keys (quote ,name))))
  #+end_src

   Approach to the key binding is laid out below:

   + =C-x= primary map (some defaults)
   + =C-c= secondary map (modes use it)
   + =C-z= tertiary map =ctl-z-map= (private custom one)
     Borrowed this idea from http://www.jurta.org/en/emacs/dotemacs
     Make the prefix key =C-z= for my personal keymap.  On
     qwerty-keyboards =C-z= is one of the most accessible keys like
     =C-x= and =C-c=, but the prefix key =C-c= is reserved  for
     mode-specific commands (both user-defined and standard Emacs
     extensions). The standard binding of =C-z= (=suspend-emacs= or
     =iconify-or-deiconify-frame=) is reassigned here to double key
     sequence =C-z C-z=.
     #+begin_src emacs-lisp
       (defvar ctl-z-map)
       (define-prefix-command 'ctl-z-map)
       (let ((c-z (global-key-binding [(control ?z)])))
         (global-unset-key [(control ?z)])
         (bind-key "C-z" 'ctl-z-map)
         (bind-key "C-z C-z" c-z))
     #+end_src

   The sequence continues with quaternary, quinary, senary,
   septenary, octonary, nonary, and denary, although most of these
   terms are rarely used. There's no word relating to the number
   eleven but there is one that relates to the number twelve:
   duodenary.

   Other maps:
   + =C-x f=  - map  file operations
     #+begin_src emacs-lisp
       (keymap-on-key ctl-x-f-map "C-x f")
     #+end_src

   + =M-g=    - goto map (already exists in Emacs24)

** TODO Key Binging To Change:
   - change =M-o= from =facemenu-keymap= to =outline-mode= keymap  =M-o=

** Possible Key Bindings
   Some of the more or less possible key binding could be:
   - =C-<capital letter>=
   - =M-<capital letter>=
   - =A-<anything>=
   - =M-A-<anything>=

   Single-letter bindings still available:
   + =C- ,'";:?<>|!#$%^&*`~ <tab>=
   + =M- ?#=

   Usually following keys are easy to press with one hand
   =M-f12=, =M-f11=, =M-f10=, =M-f9=, =M-f8=, =M-f7=

** Remapping standard commands
   #+begin_src emacs-lisp :tangle yes
     ;;; almost always hit suspend instead of repeat command
     ;;; so `repeat' is both C-x z and C-x C-z
     (let ((c-x-z (global-key-binding [(control x) ?z])))
       (global-unset-key [(control x) (control ?z)])
       (define-key ctl-x-map [(control ?z)] c-x-z))
   #+end_src


* General Settings
** User Interface
*** Appearance

    Turn off menu bar, scroll bars and tool bar.
     #+begin_src emacs-lisp
       (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
       (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
       (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
     #+end_src

     File name into the frame title
     #+begin_src emacs-lisp
       (when window-system
         (setq frame-title-format '(buffer-file-name "%f" ("%b")))
         (mouse-wheel-mode t)
         (blink-cursor-mode -1))
     #+end_src

*** Modeline Configuration

    Display time in mode-line
    #+begin_src emacs-lisp
       (display-time)
    #+end_src

    Modeline is configured using =powerline= package and =diminish=
    mode to hide information about some of the modes

    #+begin_src emacs-lisp
      (use-package diminish
        :ensure t
        :defer t)
      (use-package powerline
        :ensure t
        :config (progn
                  (defun ffy-powerline-theme ()
                    "Powerline setup for the mode-line."
                    (interactive)
                    (setq-default mode-line-format
                                  '("%e"
                                    (:eval
                                     (let* ((active (powerline-selected-window-active))
                                            (mode-line (if active 'mode-line 'mode-line-inactive))
                                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                                            (separator-left (intern (format "powerline-%s-%s"
                                                                            powerline-default-separator
                                                                            (car powerline-default-separator-dir))))
                                            (separator-right (intern (format "powerline-%s-%s"
                                                                             powerline-default-separator
                                                                             (cdr powerline-default-separator-dir))))
                                            (lhs (list (powerline-raw "%*" nil 'l)
                                                       (powerline-buffer-size nil 'l)
                                                       (powerline-raw mode-line-mule-info nil 'l)
                                                       (powerline-buffer-id nil 'l)
                                                       (when (and (boundp 'which-func-mode) which-func-mode)
                                                         (powerline-raw which-func-format nil 'l))
                                                       (powerline-raw " ")
                                                       (funcall separator-left mode-line face1)
                                                       (when (boundp 'erc-modified-channels-object)
                                                         (powerline-raw erc-modified-channels-object face1 'l))
                                                       (powerline-major-mode face1 'l)
                                                       (powerline-process face1)
                                                       (powerline-minor-modes face1 'l)
                                                       (powerline-narrow face1 'l)
                                                       (powerline-raw " " face1)
                                                       (funcall separator-left face1 face2)
                                                       (powerline-vc face2 'r)))
                                            (rhs (list (powerline-raw global-mode-string face2 'r)
                                                       (funcall separator-left face2 face1)
                                                       (powerline-raw "%4l" face1 'l)
                                                       (powerline-raw ":" face1 'l)
                                                       (powerline-raw "%3c" face1 'r)
                                                       (funcall separator-right face1 face2)
                                                       (powerline-raw " ")
                                                       (powerline-raw "%6p" nil 'r)
                                                       (powerline-hud face2 face1))))
                                       (concat (powerline-render lhs)
                                               (powerline-fill face2 (powerline-width rhs))
                                               (powerline-render rhs)))))))

                  (ffy-powerline-theme)
                  ;(powerline-default-theme)
                  (add-hook 'desktop-after-read-hook 'powerline-reset)
                  ))

    #+end_src

*** Menu bar
    Turn on the menu bar for exploring new modes
    #+begin_src emacs-lisp
      (bind-key "<f1>" 'menu-bar-mode)
      (bind-key "<C-f1>" 'imenu-add-menubar-index)
    #+end_src

** Files/Directories
*** Backups and saves
    #+begin_src emacs-lisp
            (setq save-place-file (concat *data-dir* "places")
                  backup-directory-alist `((".*" . ,*backup-dir*))
                  savehist-file (concat *data-dir* "history")
                  smex-save-file (concat *data-dir* ".smex-items")
                  recentf-save-file (concat *data-dir* ".recentf")
                  ido-save-directory-list-file (concat *data-dir* ".ido.last")
                  bookmark-default-file (concat *data-dir* "bookmarks")
                  desktop-dirname *data-dir*
                  desktop-path (list desktop-dirname)
                  desktop-save t
                  auto-save-list-file-prefix (concat *data-dir* "auto-save-list/.saves-")
                  abbrev-file-name (concat *data-dir* "abbrev_defs"))
    #+end_src

    Desktop mode allows to save/open files from the previous Emacs
    session. We set the hook that would re-read Emacs desktop file at
    the end. We execute =desktop-read= in the initialization part in
    =after-init-hook= (see =init.el=).


*** Configuration Files
    #+begin_src emacs-lisp
      (setq url-configuration-directory (file-name-as-directory (concat *data-dir* "url")))
    #+end_src

*** Files and Projects
    #+begin_src emacs-lisp
      (use-package find-file-in-project
        :ensure t
        :commands find-file-in-project)
    #+end_src

    Opening files from =recentf= list

    #+begin_src emacs-lisp
      (defun ido-choose-from-recentf ()
        "Use ido to select a recently opened file from the `recentf-list'"
        (interactive)
        (find-file (ido-completing-read "Open file: " recentf-list nil t)))
    #+end_src

    Using Projectile
    #+begin_src emacs-lisp
      (use-package projectile
        :ensure t
        :defer t
        :diminish projectile-mode)
    #+end_src


*** Files Key-Bindings

    =C-x C-f= is bound to =ido-find-file=
    =C-x f <letter>= are different file commands

    #+begin_src emacs-lisp
      (bind-key  "R"   'recentf-open-most-recent-file ctl-x-f-map)
      (bind-key  "o"   'ido-find-file-other-window    ctl-x-f-map)
      (bind-key  "f"   'find-file-in-project          ctl-x-f-map)
      (bind-key  "r"   'ido-choose-from-recentf       ctl-x-f-map)
      (bind-key  "RET" 'find-file-at-point            ctl-x-f-map)
    #+end_src

*** Dired
    Dired settings that proved useful.
    Make Dired guess where to copy files
    #+begin_src emacs-lisp
      (setq dired-dwim-target t)
    #+end_src

    Switch to "writable" =dired-mode=. It makes it very easy to rename files.
    #+begin_src emacs-lisp
      (add-hook 'dired-mode-hook
                '(lambda ()
                    (bind-key "W" 'wdired-change-to-wdired-mode dired-mode-map)))
    #+end_src


** Buffers
*** Using =IBuffer=
    Use =ibuffer= for buffer operations

    #+begin_src emacs-lisp
      (use-package ibuffer
        :bind ("C-x C-b" . ibuffer)
        :init (progn
                (defface ibuffer-custom-deletion-face '((t (:inherit error :strike-through t :underline nil))) "Buffers to be deleted")
                (defface ibuffer-custom-marked-face '((t (:inherit warning :inverse-video t :underline nil))) "Marked buffers")
                (setq ibuffer-deletion-face 'ibuffer-custom-deletion-face
                      ibuffer-marked-face 'ibuffer-custom-marked-face
                      ;; don't ask to kill buffers
                      ibuffer-expert t)
                ;; auto updateable ibuffer
                (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode)))
    #+end_src

*** Mini-buffer

    Automatically close certain buffers after exiting from
    mini-buffer
    #+begin_src emacs-lisp
      (defvar *auto-close-buffers* '("*Completions*"
                                     "*Ido Completions*")
        "List of buffers that should be closed after we done with minibuffer. Usually it is various completions buffers")

      (add-hook 'minibuffer-exit-hook
                '(lambda ()
                   (progn
                     (mapc '(lambda (buffer)
                              (if (buffer-live-p buffer)
                                  (kill-buffer buffer))) *auto-close-buffers*))))
    #+end_src

    Use =smex= in the mini-buffer. =M-x= runs command and =M-X= runs
    command for the major mode.

    #+begin_src emacs-lisp
      (use-package smex
        :ensure t
        :init
        (smex-initialize)
        ;; Smex is used in minibuffer M-x
        :bind (("M-x" . smex)
               ("M-X" . smex-major-mode-commands)))
    #+end_src

    We are trying to make keys working in both Windows and Mac OS X to
    be able to =M-x= without meta

    #+begin_src emacs-lisp
      (bind-key "C-x C-m"  'execute-extended-command)
    #+end_src

*** Operations On Buffers
**** Buffer Switching

     #+begin_src emacs-lisp
       (defun ffy-display-prev-next-buffers ()
         "Show two previous, current and two next buffer names in the echo area.
       Example:
       -2:*Messages* -1:*Help*    0:.emacs      1:*info*  2:*scratch*

       From http://www.jurta.org/en/emacs/dotemacs"
         (interactive)
         (let ((i -3) b (bl (buffer-list (selected-frame))) (message-log-max nil))
           (message "%s"
                    (mapconcat
                     (lambda (x)
                       (setq i (+ i 1))
                       (format "%d:%-12s"
                               i (substring (buffer-name x) 0
                                            (min (length (buffer-name x)) 11))))
                     (append
                      (nreverse
                       (list
                        (setq b (get-next-valid-buffer (reverse bl) t))
                        (get-next-valid-buffer (cdr (memq b (reverse bl))) t)))
                      (list (current-buffer))
                      (list
                       (setq b (get-next-valid-buffer (cdr bl) t))
                       (get-next-valid-buffer (cdr (memq b bl)) t)))
                     " "))))
     #+end_src

     Show adjacent buffers in the minibuffer on switch

     #+begin_src emacs-lisp
       (defadvice previous-buffer (after my/previous-buffer activate)
         (ffy-display-prev-next-buffers))

       (defadvice next-buffer (after my/next-buffer activate)
        (ffy-display-prev-next-buffers))
     #+end_src

**** Other Operations
     #+begin_src emacs-lisp
       (bind-key "b k" 'kill-this-buffer ctl-z-map)
       ;;; Buffer operations in C-z map
       (bind-key "b y" 'bury-buffer  ctl-z-map)
       (bind-key "b r" 'revert-buffer  ctl-z-map)
       ;;; revert buffer on f5
       (bind-key "<f5>" 'revert-buffer)
     #+end_src

     Other useful combos:
     - =C-x 4 0= - kill-buffer-and-window (works with current buffer
       only)
     - =C-x 4 b= - ido open buffer other window

     Often I need to create temporary buffer

     #+begin_src emacs-lisp
       (defun ffy-create-temp-buffer ()
         "Creates temporary buffer"
         (interactive)
         (switch-to-buffer "*temp* "))

       (bind-key "b t" 'ffy-create-temp-buffer ctl-z-map)
     #+end_src

** Windows

   Let's put window operations on =C-z w=
   #+begin_src emacs-lisp
     (keymap-on-key ctl-z-w-map "C-z w")
   #+end_src

   #+begin_src emacs-lisp
     (use-package window
       :bind (("C-z w k" . delete-window)
              ("C-z w m" . delete-other-windows)))
   #+end_src

   Using =Windmove= for switching between windows in Emacs

   #+begin_src emacs-lisp :preamble # -*- coding: utf-8 -*-
     (windmove-default-keybindings 'super) ;; ⌘+direction
   #+end_src

   Moving in a window
   #+begin_src emacs-lisp
;(bind-key "t" (make-interactive move-to-window-line 0)  goto-map)
;(bind-key "b" (make-interactive move-to-window-line -1)  goto-map)
   #+end_src

*** Typical window operations but faster
(bind-key "M-0" 'delete-window)
(bind-key "M-1" 'delete-other-windows)
(bind-key "M-2" 'split-window-vertically)
(bind-key "M-3" 'split-window-horizontally)

*** Windows configurations
(define-key global-map [(control x) (super left)] 'winner-undo)
(define-key global-map [(control x) (super right)] 'winner-redo)


** Help System
   Some of the useful functions and setting dealing with Info system
   in emacs:
   #+begin_src emacs-lisp
     (use-package help-mode+ :ensure t)
     (use-package help+ :ensure t)
     (use-package help-fns+ :ensure t)
   #+end_src

   =apropos= seems to be more useful than =apropos-command=

   #+begin_src emacs-lisp
     (bind-key "C-h a" 'apropos)
     (bind-key "C-b" #'describe-personal-keybindings help-map)
   #+end_src


** Spell checker
   We could use Hunspell or Aspell. Hunspell seems to be better for
   spellchecking. Even though it requires building up from the
   source code it is worth it.

   Link to the binary for Windows
   http://sourceforge.net/projects/ezwinports/files/hunspell-1.3.2-3-w32-bin.zip/download

   #+begin_src emacs-lisp
     (use-package flyspell
       :bind-keymap ("C-z i" . flyspell-mode-map)
       :init
       (use-package ispell
         :config (progn
                   ;; Personal dictionary setup
                   ;; if file doesn't exist then create it
                   (setq ispell-personal-dictionary (let ((personal-dictionary-file (concat *data-dir* ".personal.dict")))
                                                      (unless (file-exists-p personal-dictionary-file)
                                                        (with-temp-file personal-dictionary-file t))
                                                      personal-dictionary-file))
                   ;; Aspell Specific
                   (when (executable-find "aspell")
                     (setq ispell-program-name "aspell"
                           ispell-extra-args '("--sug-mode=ultra")))
                   ;; Hunspell Specific
                   (when (executable-find "hunspell")
                     (setq ispell-program-name "hunspell"))
                   )))
   #+end_src

   Some =Hunspell= related settings to a modern emacs (version >=
   24.4) is here
   http://lists.gnu.org/archive/html/help-gnu-emacs/2014-04/msg00030.html


** Miscellaneous
   Here we collect settings and commands that don't really fall into
   any specific category

   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
     (random t)
   #+end_src

** IDO settings
   IDO mode speeds up some of the tasks. Some of the IDO settings that
   have been taken out from the customization file.
   #+begin_src emacs-lisp
     (use-package ido
       :config
       (progn
         (use-package ido-ubiquitous :ensure t)
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t)

         ;; not every command should could be ido-ed
         ;; kill-ring-search has already set of minibuffer commands that don't
         ;; work well with ido-completing-read
         (setq ido-ubiquitous-command-exceptions '(kill-ring-search))

         (defun ffy--change-ido-override (behavior func-name)
           "Changes `ido-ubiquitous-function-overrides` variable for a function FUNC-NAME by setting its behavior to BEHAVIOR"
           (setq ido-ubiquitous-function-overrides
                 (mapcar (lambda (override) (if  (equal (caddr override) ,func-name)
                                           (cons ,behavior (cdr override))
                                         override))
                         ido-ubiquitous-function-overrides)))

         (defmacro enable-ido-for (func-name)
           "Enables IDO for a function using `ido-ubiquitous' mode"
           `(ffy--change-ido-override 'enable ,func-name))

         (defmacro disable-ido-for (func-name)
           "Disables IDO for a function using `ido-ubiquitous' mode"
           `(ffy--change-ido-override 'disable ,func-name))))
   #+end_src



* Editing

** Appearance
   Visual lines mode makes lines longer than window width can be
   displayed so that they are wrapped at word boundary. By default it
   is off and we want it on only for text editing modes, such as
   =latex-mode=, =markdown-mode=, etc. One can call
   =visual-line-mode= to toggle on/off.

   Visual line mode actually does several things. From a user's point
   of view, it:
   -  Makes lines wrap at word boundaries. (controlled by var
      =truncate-lines= and =word-wrap=.)
   -  Makes up/down arrow keys move by a visual line. (controlled by
      the var =line-move-visual=.)
   -  Makes the =kill-line= command delete by a visual line, as
      opposed to a logical line.
   -  Turns off the display of little return arrow at the edge of
      window. (controlled by the var =fringe-indicator-alist=.)

   #+begin_src emacs-lisp :tangle yes
     (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
   #+end_src

   Highlighting and coloring of the buffer
   #+begin_src emacs-lisp
     (use-package idle-highlight-mode :ensure t)
     (use-package rainbow-mode        :ensure t)
     (use-package rainbow-delimiters  :ensure t)
   #+end_src

   Also helpful is to highlight the current word
   #+begin_src emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :config  (progn
                  (highlight-symbol-mode +1)
                  (bind-key "<C-return>" 'highlight-symbol-at-point      ctl-z-map)
                  (bind-key "<C-up>"     'highlight-symbol-prev          ctl-z-map)
                  (bind-key "<C-down>"   'highlight-symbol-next          ctl-z-map)
                  (bind-key "@"          'highlight-symbol-query-replace ctl-z-map)))
   #+end_src

   Turn on/off showing trailing whitespace

   #+begin_src emacs-lisp
     (defun toggle-show-trailing-whitespace ()
       "Turns on/off showing of the trailing whitespaces in a current buffer"
       (interactive)
       (setq show-trailing-whitespace (not show-trailing-whitespace)))

     (defun turn-off-show-trailing-whitespace ()
       "Turns off trailing-whitespace mode - useful for REPLs"
       (interactive)
       (setq show-trailing-whitespace nil))
   #+end_src


** Completions
*** Regular hippie-expand
    Naturally =hippie-expand-try-functions-list= would be made local
    variable and adjusted for a mode in the mode settings
    #+begin_src emacs-lisp
      (bind-key "M-/"  'hippie-expand)
    #+end_src

*** Company
    Due to inconveniences of the =auto-complete= package use =company=
    instead
    #+begin_src emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :config (progn
                  (setq company-idle-delay 0.2
                        company-tooltip-limit 20
                        company-show-numbers t
                        company-selection-wrap-around t
                        company-minimum-prefix-length 2
                        company-tooltip-align-annotations t
                        company-echo-delay 0))
        :init
        (global-company-mode 1)
        (bind-key "C-d" #'company-show-doc-buffer  company-active-map)
        (bind-key "M-?" #'company-complete))
    #+end_src


** Zapping

   Some of the zapping functions:

   - =zap-up-to-char= is a better alternative to regular zapping
     #+begin_src emacs-lisp
       (autoload 'zap-up-to-char "misc" "Kill up to, but not including ARGth occurrence of CHAR.
         \(fn arg char)" 'interactive)
     #+end_src

   - =zap-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-to-char-backwards (char)
           (interactive "cZap to char backwards: ")
           (zap-to-char -1 char))
     #+end_src

   - =zap-up-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-up-to-char-backwards (char)
           (interactive "cZap up to char backwards: ")
           (zap-up-to-char -1 char))
     #+end_src

  Zapping key bindings
  #+begin_src emacs-lisp
    (bind-key "C-M-z"   'zap-to-char-backwards)
    (bind-key "M-Z"     'zap-up-to-char)
    (bind-key "C-M-S-z" 'zap-up-to-char-backwards)
  #+end_src


** Kill-rings

   Searching and browsing through the =kill-ring=
   #+begin_src emacs-lisp
     (use-package browse-kill-ring
       :ensure t
       :config  (progn
                  (browse-kill-ring-default-keybindings) ; advises M-y
                  (bind-key "C-x C-y" 'browse-kill-ring)))
     (use-package kill-ring-search
       :ensure t
       :config  (progn
                  (bind-key "C-M-y" 'kill-ring-search)))
   #+end_src



** Search
*** Search in a Buffer
    #+begin_src emacs-lisp
      (bind-key "C-S-r"  'search-backward)
      (bind-key "C-S-s"  'search-forward)
    #+end_src
*** Search in Files
    #+begin_src emacs-lisp
      (use-package grep
        :defer t
        :config
        (progn
          (setq wgrep-enable-key "e")
          (bind-key "e" 'wgrep-change-to-wgrep-mode  grep-mode-map)))
    #+end_src

    In addition to =grep= we use =ag=
    #+begin_src emacs-lisp
      (use-package ag
        :ensure t)
    #+end_src


** Navigation and Positioning

*** Better BOL positioning

   First define better function =ffy-bol-or-back-to-indent= to
   position either to the beginning of the line or beginning of the
   indent and switch between this two positions if necessary

     #+begin_src emacs-lisp
       (defun ffy-bol-or-back-to-indent ()
         "In addition to having two different mappings for
        (move-beginning-of-line ARG) and (back-to-indentation) we
        will have a function that goes to BOL if we are on the
        indent position and to the indent if we are at the BOL"
         (interactive)
         (if (bolp)
             (back-to-indentation)
           (move-beginning-of-line 1)))
     #+end_src

   Redefine =C-a= to =C-S-a= and =C-a to the =ffy-bol-or-back-to-indent=

   #+begin_src emacs-lisp
     (bind-key "C-S-a" (key-binding [(control ?a)]))
     (bind-key "C-a"  'ffy-bol-or-back-to-indent)
   #+end_src

*** Navigation Using Mark/Point Ring
    For better explanation see
    http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/

    Pushes mark into a ring without activating a region
    #+begin_src emacs-lisp
      (defun ffy-position-to-ring ()
        "Pushes current position to the mark-ring"
        (interactive)
        (push-mark (point) t nil)
        (message "Position %s pushed to the ring" (point)))

      (bind-key  "M-SPC" 'ffy-position-to-ring)
    #+end_src

*** Ace Jumping
    #+begin_src emacs-lisp
      (use-package ace-jump-mode
        :ensure t
        :bind ("C-z SPC" . ace-jump-mode))
    #+end_src

** Marking

   Mark commands from =thing-cmds=
   #+begin_src emacs-lisp
     (use-package thing-cmds
       :ensure t
       :init (thgcmd-bind-keys))
   #+end_src


** Undo
   Undo/Redo functionality is done through =undo-tree=
   #+begin_src emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :config (global-undo-tree-mode))
   #+end_src


** Miscellaneous

   - toggles line numbers in the buffer
   #+begin_src emacs-lisp
     (bind-key "C-S-l"  'linum-mode)
   #+end_src

   - =IMenu= defaults
     #+begin_src emacs-lisp
       (set-default 'imenu-auto-rescan t)
     #+end_src

   - use =C-\= to leave one space between words
     #+begin_src emacs-lisp
       (define-key global-map [(control ?\\)] 'just-one-space)
     #+end_src

   - there's default =M-^= =delete-indentation= that is an alias to
     =join-line=
     #+begin_src emacs-lisp
       (bind-key "j" 'join-line ctl-z-map)
       (bind-key "J" (lambda () "joins next line to this one"
                                      (interactive)
                                      (join-line 1)) ctl-z-map)
     #+end_src

*** Narrowing/Widening
    Enable useful disabled Narrow/Widen commands
    #+begin_src emacs-lisp
      (dolist (command '(narrow-to-region narrow-to-defun narrow-to-page widen set-goal-column))
        (put command 'disabled nil))
    #+end_src

*** Thing At the Point
    Let's load up =thingatpt= and =thingatpt+= libraries and create
    additional functions that will change number at the point (if
    point is at the number):
    #+begin_src emacs-lisp
      (use-package thingatpt
        :defer t
        :config (progn
                  (use-package thingatpt+
                    :ensure t
                    :config (progn
                              ;; Rectifying the problem with some code (e.g.
                              ;; CIDER) that relies on standard behaviour
                              ;; of the tap functions
                              (tap-put-thing-at-point-props)
                              ;;(tap-redefine-std-fns) ;; This breaks CIDER
                              ;; This depends on the thingatpt and thingatpt+
                              (defun ffy-tap-number-change (&optional num)
                                "Changes the number at the point by `num' passed as a prefix argument. If no argument is passed then it uses 1, i.e. decrements and increments number at the point. If it is not a number at the point, then nothing happens."
                                (interactive "p")
                                (save-excursion
                                  (let ((n (tap-number-at-point-decimal))
                                        (bounds (tap-bounds-of-number-at-point)))
                                    (if (and n bounds)
                                        (progn
                                          (delete-region (car bounds) (cdr bounds))
                                          (insert (number-to-string (+ n (or num 1)))))))))

                              (defun ffy-tap-number-decrease (&optional num)
                                "Decreases number at the point by `num' or 1 if argument is not given"
                                (interactive "p")
                                (ffy-tap-number-change (- (or num 1))))

                              (defun ffy-tap-number-increase (&optional num)
                                "Increases number at the point by `num' or 1 if argument is not given"
                                (interactive "p")
                                (ffy-tap-number-change (or num 1)))

                              (bind-key "C--"  'ffy-tap-number-decrease)
                              (bind-key "C-+"  'ffy-tap-number-increase)))))
    #+end_src

    At the end we have keys =C--= and =C-+= bound to decreasing
    number at the point and increasing number at the point.




** Snippets
   Snippets allow us to create code quickly
*** Yasnippets
    #+begin_src emacs-lisp
      (use-package yasnippet
        :ensure t
        :config  (progn
                   (use-package dropdown-list :ensure t)
                   (setq-default yas-wrap-around-region t)
                   (add-to-list 'yas-snippet-dirs (concat *data-dir*  "snippets"))
                   ;; Prevent Yasnippet from loading default c++ snippets
                   (let ((file (concat yas-installed-snippets-dir "/c++-mode" "/.yas-skip")))
                     (when (not (file-exists-p file))
                       (write-region "" nil file)))
                   (yas-global-mode +1)
                   ;; add to hippie-expand
                   (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)))
    #+end_src

** Bookmarking

   #+begin_src emacs-lisp
     (use-package bm
       :ensure bm)

     (use-package bookmark
       :defer t
       :config
       (progn
         (use-package bookmark+
           :ensure t)))
   #+end_src


* Version Control Systems
** Git
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :commands magit-status
       ;; Added global shortcut to run Magit
       :bind ("C-x g" . magit-status)
       :config (progn
                   ;(setq magit-auto-revert-mode nil)
                   (setq magit-last-seen-setup-instructions "1.4.0")))
   #+end_src


* Specific Modes
** Org Mode
   Org-mode is a submodule of this repository. More so I had to create a repo on bitbucket.com
   so it could be successfly cloned on any machine (via https not git protocol).

   First of all go into =site-lisp/org-mode= and run =make autoloads= and =make info=. These
   commands will create all necessary files: org-loaddefs.el and info files.

   On Mac OS X there could be a problem, while running make in =site-lisp/org-mode= directory
   it will break with the dialog "This application will not run on your computer. Sorry!". This
   is a problem of launching script. Edit =/Application/Emacs.app/Contents/MacOS/Emacs= file - replace
   line
#+begin_src ruby
  exec versions[highest_compatible_version], *ARGV
#+end_src
 With
#+begin_src ruby
  executable = versions[highest_compatible_version], *ARGV
  exec %("#{executable}")
#+end_src

   If that doesn't help just update Emacs.

   Now Emacs should load new org-mode.

   #+begin_src emacs-lisp
     (use-package org
       :ensure t
       :defer t
       :bind (("C-&" . org-mark-ring-goto)
              ("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c b" . org-iswitchb))
              ;(bind-key "C-&" 'org-mark-ring-goto  mode-specific-map) ;; due to the conflict with Yasnippet
       :init (progn
               (setq org-completion-use-ido t
                     ;; org-completion-use-iswitchb t     ; without it ido completion is
                     ;;                                   ; not going to work for
                     ;;                                   ; org-mode (see `org-read-property-value')
                     org-hide-leading-stars t
                     org-return-follows-link t
                     org-modules '(org-docview
                                   org-gnus
                                   org-id
                                   org-info
                                   org-jsinfo
                                   org-protocol
                                   org-special-blocks
                                   org-w3m
                                   org-bookmark
                                   org-elisp-symbol
                                   org-panel)
                     org-empty-line-terminates-plain-lists t
                     org-confirm-babel-evaluate nil    ; do not ask about evaluating babel
                     org-src-fontify-natively t        ; syntax highlighting
                     )
               ;; TODO: Should it be moved to a :config part ???
               (org-babel-do-load-languages
                'org-babel-load-languages
                '((dot . t)
                  (ditaa . t)
                  (emacs-lisp . t)
                  (python . t)))
     
               ;; make company completion work in Org-Mode
               (defun add-pcomplete-to-capf ()
                 (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
     
               ;(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
               (dolist (it '(turn-on-font-lock
                             yas-minor-mode-on
                             turn-on-auto-fill
                             turn-on-flyspell
                             hl-line-mode
                             add-pcomplete-to-capf
                             iimage-mode))
                       (add-hook 'org-mode-hook it)))
       :config (progn
                 ;; Override not working function from org-mode
                 (defun org-read-property-value (property)
                   "Read PROPERTY value from user."
                   (let* ((completion-ignore-case t)
                          (allowed (org-property-get-allowed-values nil property 'table))
                          (cur (org-entry-get nil property))
                          (prompt (concat property " value"
                                          (if (and cur (string-match "\\S-" cur))
                                              (concat " [" cur "]") "") ": "))
                          (set-function (org-set-property-function property))
                          (val (if allowed
                                   (funcall set-function prompt allowed nil
                                            (not (get-text-property 0 'org-unrestricted
                                                                    (caar allowed))))
                                 (funcall set-function prompt
                                          (mapcar 'list (org-property-values property))
                                          nil nil "" nil cur))))
                     (if (equal val "")
                         cur
                       val)))
                 )
     
     ;(setq org-todo-keyword-faces
     ;      (quote (("TODO" :foreground "medium blue" :weight bold)
     ;              ("NOTE" :foreground "dark violet" :weight bold)
     ;              ("STARTED" :foreground "dark orange" :weight bold)
     ;              ("WAITING" :foreground "red" :weight bold)
     ;              ("DELEGATED" :foreground "red" :weight bold))))
     
     ;(defun my-org-mode-custom-bindings ()
     ;  "customize org-mode keys"
     ;  (local-set-key [(control up)] 'outline-previous-visible-heading)
     ;  (local-set-key [(control down)]  'outline-next-visible-heading)
     ;  (local-set-key [(control meta up)]  'outline-up-heading)
     ;  (local-set-key [(control c) (meta ?w)] 'org-store-link )
     ;  (local-set-key [(control c) (control ?y)] 'org-insert-link)
     ;  (local-set-key [(control c) ?a] 'org-agenda))
     
     
     ;(dolist (mode '(org-mode))
     ;  (add-to-list 'ac-modes mode))
     
     ;;
     ;;  Setup iimage working with Org-mode
     ;;
     ;; (add-hook 'org-mode-hook 'turn-on-iimage-mode)
     
     ;; (defun org-toggle-iimage-in-org ()
     ;;   "display images in your org file"
     ;;   (interactive)
     ;;   (if (face-underline-p 'org-link)
     ;;       (set-face-underline-p 'org-link nil)
     ;;     (set-face-underline-p 'org-link t))
     ;;   (iimage-mode))
     
     
     )
   #+end_src
*** Using OX-REVEAL

#+begin_src emacs-lisp
  (use-package ox-reveal
    :config (progn
              ;; Overriding the org-reveal-src-block
              ;; to make it work with highlight.js
              (when nil
                (defun org-reveal-src-block (src-block contents info)
                  "Transcode a SRC-BLOCK element from Org to Reveal.
  CONTENTS holds the contents of the item.  INFO is a plist holding
  contextual information."
                  (if (org-export-read-attribute :attr_html src-block :textarea)
                      (org-html--textarea-block src-block)
                    (let ((lang (org-element-property :language src-block))
                          (caption (org-export-get-caption src-block))
                          (code (org-html-format-code src-block info))
                          (frag (org-export-read-attribute :attr_reveal src-block :frag))
                          (label (let ((lbl (org-element-property :name src-block)))
                                   (if (not lbl) ""
                                     (format " id=\"%s\""
                                             (org-export-solidify-link-text lbl))))))
                      (if (not lang)
                          (format "<pre %s%s>\n%s</pre>"
                                  (or (frag-class frag) " class=\"example\"")
                                  label
                                  code)
                        ;;        (format
                        ;;         "<div class=\"org-src-container\">\n%s%s\n</div>"
                        ;;         (if (not caption) ""
                        ;;           (format "<label class=\"org-src-name\">%s</label>"
                        ;;                   (org-export-data caption info)))
                        ;;          ;; Formatting code for highlight.js
                        ;; )
                        (format "\n<pre><code class=\"hljs %s\">%s</code></pre>"
                                ;; (or (frag-class frag)
                                ;;     (format " class=\"src src-%s\"" lang))
                                ;; label
                                lang
                                (car (org-export-unravel-code src-block)))))))

                )))
#+end_src


** Orgtbl mode
   More about orgtbl
   http://dynamic-thinking.blogspot.com/2009/11/orgtbl-mode.html
    #+begin_src emacs-lisp
      (use-package orgtbl
        :disabled t
        :commands orgtbl-mode
        :config (progn
                  (defun orgtbl-to-gfm (table params)
            "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown.
      Usage Example:
        <!--- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
        <!--- END RECEIVE ORGTBL $1 -->
        <!---
        ,#+ORGTBL: SEND $1 orgtbl-to-gfm
         | $0 |
        -->
      For more details see https://gist.github.com/grafov/8244792 and https://gist.github.com/yryozo/5807243
      "
            (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                                         org-table-last-alignment ""))
                   (params2
                    (list
                     :splice t
                     :hline (concat alignment "|")
                     :lstart "| " :lend " |" :sep " | ")))
              (orgtbl-to-generic table (org-combine-plists params2 params))))))
    #+end_src


** Markdown
   #+begin_src emacs-lisp
     (use-package markdown-mode
       :ensure t
       :config  (progn
                  (defun set-markdown-mode-outline-regexp ()
                    "Add Markdown mode specifics.  Make outline-mode navigation work for underline headers as well"
                    (make-local-variable 'outline-regexp)
                    (setq outline-regexp "#+\\|^\\(.*\\)\n\\(===+\\|---+\\)$"))

                  (add-hook 'markdown-mode-hook 'set-markdown-mode-outline-regexp)
                  (add-hook 'markdown-mode-hook 'orgtbl-mode)))
   #+end_src



** XSL/XML Editing
   #+begin_src emacs-lisp
     (defun xml-pretty-print (begin end)
       "Makes current buffer with XML markup look prettier"
       (save-excursion
         (nxml-mode)
         (goto-char begin)
         (while (search-forward-regexp "\>[ \\t]*\<" nil t) 
           (backward-char) (insert "\n"))
         (indent-region begin end))
       (message "Ah, much better!"))
     
     (defun xml-pretty-print-region (begin end)
       "Pretty format XML markup in region. You need to have nxml-mode
     http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
     this.  The function inserts linebreaks to separate tags that have
     nothing but whitespace between them.  It then indents the markup
     by using nxml's indentation rules."
       (interactive "r")
       (xml-pretty-print begin end))
     
     (defun xml-pretty-print-buffer ()
       "Formats whole buffer containing XML"
       (interactive)
       (xml-pretty-print-region (point-min) (point-max)))
     
     (setq-default
      ;; Treat elements and contents like S-expressions! Oh, the magic. 
      ;; (if you know S-expression movement commands, it's great) 
      nxml-sexp-element-flag t
       ;; Whenever you type </ it will fill out the rest. 
      nxml-slash-auto-complete-flag t)
     
     
     ;; Causes files with extensions .xml .xsl .rng .xhtml .html and .tal
     ;; to invoke nxml-mode.
     (setq auto-mode-alist 
           (cons '("\\.\\(xml\\|xsl\\|rng\\|tal\\|xsd\\|sch\\|xslt\\|svg\\|rss\\)\\'" . nxml-mode) 
                 (remove-if (lambda (x) (eq (cdr x) 'html-mode)) auto-mode-alist)))
     
     ;; another way to recognize XML files 
     (setq magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
     ;(push '("<\\?xml" . nxml-mode) magic-mode-alist)
     
     (defun ffy-customize-nxml-mode ()
       "This function sets some variables and calls some functions that setup nXML mode."
       ;; load hide show modes 
       (local-set-key "\C-c/" 'nxml-finish-element)
       (local-set-key [return] 'newline-and-indent)
       ;;(auto-fill-mode)
       (rng-validate-mode)
       (unify-8859-on-decoding-mode)
       (setq ispell-skip-html t)
       (hs-minor-mode 1)
       ;; controversial 
       (make-variable-buffer-local 'ido-use-filename-at-point)
       (setq ido-use-filename-at-point nil))
     
     (add-hook 'nxml-mode-hook 'ffy-customize-nxml-mode)
     
     (add-to-list 'hs-special-modes-alist
                  '(nxml-mode
                    "\\|<[^/>]&>\\|<[^/][^>]*[^/]>"
                    ""
                    nil))
     ;;; Add auto-complete to the the XML based modes 
     ;(dolist (mode '(nxml-mode))
     ;  (add-to-list 'ac-modes mode))
   #+end_src


** HTML and XHTML and other markup mode setup setup
   #+begin_src emacs-lisp
;; (dolist (mode '(html-mode yaml-mode  textile-mode))
;;   (add-to-list 'ac-modes mode)
   #+end_src



** TeX
   TeX editing and preview. We are using AucTeX. You can see their
   web-site for instructions.

   For installing AucTeX on Windows:
   - Download and install the pre-compiled bundle of [[http://www.gnu.org/software/auctex/download-for-windows.html][AucTeX]].
   - Unpack that archive into an Emacs directory (even though it says
     do not use pre-built thing with anything other than Emacs 24.2,
     it works with Emacs 24.3). Before you do that backup your
     ~Emacs/info/dir~ file, then compare the two (new dir and backup
     dir) and copy whatever is missing from the backed up one to the
     new one.


   Links:
   - http://cseweb.ucsd.edu/~s1pan/install_auctex.html
   - http://www.gnu.org/software/auctex/download-for-windows.html


   Another option is to install it using ELPA

   #+begin_src elisp
     (use-package auctex
       :ensure t
       :init (progn
               (load "auctex-pkg.el" nil t t)
               (load "preview.el" nil t t)))
   #+end_src


   For XeTeX use command ~M-x TeX-engine-set~


   Good viewer for PDF (and other files) on Windows is
   [[http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html][Sumatra PDF]].

   Setting up Tex previewer
   http://tex.stackexchange.com/questions/119645/emacs-auctex-view-command


*** ConTeXt specifics
    For the Context we assume that version MKiV is used. Then
    everything is run via =mtxrun= or =context= commands.

    



** Shell
   Setup for the shell window in the Emacs
   #+begin_src emacs-lisp :tangle yes
     (add-hook 'shell-mode-hook #'turn-off-show-trailing-whitespace)
   #+end_src

* Programming

** General Programming

*** Programming Modes Hook

    All programming modes will benefit from following functions:

    - =local-column-number-mode=
      #+begin_src emacs-lisp
        (defun local-column-number-mode ()
          (make-local-variable 'column-number-mode)
          (column-number-mode t))

        (add-hook 'prog-mode-hook #'local-column-number-mode)
      #+end_src
    - =local-comment-auto-fill=
      #+begin_src emacs-lisp
        (defun local-comment-auto-fill ()
          (set (make-local-variable 'comment-auto-fill-only-comments) t)
          (auto-fill-mode t))

        (add-hook 'prog-mode-hook #'local-comment-auto-fill)
      #+end_src
    - =turn-on-hl-line-mode=
      #+begin_src emacs-lisp
        (defun turn-on-hl-line-mode ()
          (if window-system (hl-line-mode t)))

        (add-hook 'prog-mode-hook #'turn-on-hl-line-mode)
      #+end_src
    - =pretty-greek=  replaces words like
      _lambda_ and _alpha_ with Greek symbols
      #+begin_src emacs-lisp
        (defun pretty-greek ()
          (let ((greek '("alpha" "beta" "gamma" "delta" "epsilon" "zeta" "eta" "theta" "iota" "kappa" "lambda" "mu" "nu" "xi" "omicron" "pi" "rho" "sigma_final" "sigma" "tau" "upsilon" "phi" "chi" "psi" "omega")))
            (loop for word in greek for code = 97 then (+ 1 code) do
                  (let ((greek-char (make-char 'greek-iso8859-7 code)))
                    (font-lock-add-keywords
                     nil
                     `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[a-zA-Z]")
                        (0
                         (progn
                           (decompose-region (match-beginning 2)
                                             (match-end 2))
                           nil)))))
                    (font-lock-add-keywords
                     nil
                     `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[^a-zA-Z]")
                        (0
                         (progn
                           (compose-region (match-beginning 2)
                                           (match-end 2) ,greek-char)
                           nil)))))))))

        (add-hook 'prog-mode-hook #'pretty-greek)
      #+end_src
    - =turn-on-fic-mode= highlights FIXME and XXX in the comments
      #+begin_src emacs-lisp
        (autoload 'turn-on-fic-mode "fic-mode")
        (add-hook 'prog-mode-hook #'turn-on-fic-mode)
      #+end_src
    - =turn-on-flyspell-prog-mode=
      #+begin_src emacs-lisp
        (defun turn-on-flyspell-prog-mode ()
          (when (and (boundp 'ispell-program-name)
                     (executable-find ispell-program-name))
            (flyspell-prog-mode)))

        (add-hook 'prog-mode-hook #'turn-on-flyspell-prog-mode)
      #+end_src
    - =flycheck= checking the code on the fly
      #+begin_src emacs-lisp
        (use-package flycheck
          :ensure t
          :config (add-hook 'prog-mode-hook #'flycheck-mode))
      #+end_src
    - =turn-on-electric-mode= inserts pair symbol
      #+begin_src emacs-lisp
        (defun turn-on-electric-mode ()
          (electric-pair-mode +1))
      #+end_src

*** Global tags
    Make sure GNU Global is installed. Mac has port for that and binaries
    for Windows are [[http://adoxa.altervista.org/global/][here]]
    #+begin_src emacs-lisp
      (use-package ggtags
        :ensure t
        :init (progn
                (defun turn-on-ggtags-mode ()
                  (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                    (ggtags-mode 1)))
      
                (add-hook 'c-mode-common-hook 'turn-on-ggtags-mode)))
    #+end_src


** Paredit
   Nice mode for dealing with all those parentheses in lisp modes
   #+begin_src emacs-lisp
     (use-package paredit
       :ensure t
       :diminish paredit-mode
       :config (progn
                 (defun ffy-paredit-forward-delete ()
                   "Forces deleting a character in ParEdit mode"
                   (paredit-forward-delete +1))

                 (bind-key "C-S-d" 'ffy-paredit-forward-delete  paredit-mode-map)

                 (defun ffy-init-lisp-minibuffer-enable-paredit-mode ()
                   "Enable function `paredit-mode' during `eval-expression'. Adding `paredit-mode' for an `eval-expression' in minibuffer. RET  works as an exit minibuffer with evaluation."
                   (if (eq this-command 'eval-expression)
                       (when (fboundp 'paredit-mode)
                         (paredit-mode +1))))
                 ;; this will enable paredit in mini-buffer
                 (add-hook 'minibuffer-setup-hook 'ffy-init-lisp-minibuffer-enable-paredit-mode)))
   #+end_src


** Emacs Lisp
   Modes that deal with Emacs-Lisp
   #+begin_src emacs-lisp
     (defconst *emacs-lisp-modes* '(emacs-lisp-mode lisp-mode ielm-mode))
   #+end_src

   Use ~eldoc-mode~ for buffer and mini-buffer

   #+begin_src emacs-lisp
     (use-package eldoc
       :defer t
       :diminish eldoc-mode
       :commands eldoc-mode
       :init (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode))
   #+end_src


   SLIME-like navigation in emacs
   #+begin_src emacs-lisp
     (use-package elisp-slime-nav
       :ensure t
       :diminish elisp-slime-nav-mode
       :init (progn
               (defun turn-on-elisp-slime-nav-mode ()
                 "Turns SLIME style navigation on in Emacs-lisp."
                 (elisp-slime-nav-mode 1))))
   #+end_src

   Add Emacs-Lisp specific completions and navigation mode to the
   setup of Emacs-Lisp modes

   #+begin_src emacs-lisp
     (defun ffy-init-emacs-lisp-modes ()
       "Only emacs-lisp related things."
       (progn
         (make-local-variable 'hippie-expand-try-functions-list)
         (add-to-list 'hippie-expand-try-functions-list
                      'try-complete-lisp-symbol
                      'to-the-end)
         (add-to-list 'hippie-expand-try-functions-list
                      'try-complete-lisp-symbol-partially
                      'to-the-end)
         (when (fboundp 'highlight-parentheses-mode)
           (highlight-parentheses-mode +1))
         (bind-key "<M-return>" 'reindent-then-newline-and-indent  lisp-mode-shared-map)
         (bind-key "C-x x" 'eval-print-last-sexp  lisp-mode-shared-map)))

     (dolist (mode *emacs-lisp-modes*)
       (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
         (mapc (apply-partially 'add-hook mode-hook)
               '(ffy-init-emacs-lisp-modes
                 enable-paredit-mode
                 turn-on-elisp-slime-nav-mode
                 turn-on-eldoc-mode
                 rainbow-delimiters-mode-enable))))
   #+end_src

*** IELM - Emacs Lisp Interpreter
    Interpreter of Emacs-Lisp running in Emacs. Very helpful if we
    want run some command or change settings or instrument
    major/minor mode of the buffer we currently working on

    We want to indent if we press =RET= while inside of the
    S-expression and execute it if we are at the end.

    #+begin_src emacs-lisp
      (defun ffy-ielm-return ()
        "Like `ielm-return' but more intellectual when it comes to deciding when just
      send `paredit-newline' instead.
      Implementation shamelessly stolen from: https://github.com/jwiegley/dot-emacs/blob/master/init.el"
        (interactive)
        (let ((end-of-sexp (save-excursion
                                 (goto-char (point-max))
                                 (skip-chars-backward " \t\n\r")
                                 (point))))
              (if (>= (point) end-of-sexp)
                  (progn
                    (goto-char (point-max))
                    (skip-chars-backward " \t\n\r")
                    (delete-region (point) (point-max))
                    (call-interactively #'ielm-return))
                (call-interactively #'paredit-newline))))
    #+end_src

    Hook =ffy-ielm-return= onto the =RET= key

    #+begin_src emacs-lisp
      (defun ffy-setup-ielm ()
        "Sets some IELM defaults and keys."
        (interactive)
        (progn
          (local-set-key [return] 'ffy-ielm-return)))
    #+end_src

    And add it to the  IELM setup hook
    #+begin_src emacs-lisp
      (add-hook 'ielm-mode-hook 'ffy-setup-ielm)
    #+end_src


    We want to start new IELM session with the current buffer only if
    we don't have IELM running. If we do, we just want to switch to
    IELM instead

    #+begin_src emacs-lisp
      (defun ffy-ielm ()
        "Starts IELM or switches to existing one in the new window and sets working buffer of IELM to the current buffer."
        (interactive)
        (let ((buf (current-buffer)))
          (if (get-buffer "*ielm*")
              (switch-to-buffer-other-window "*ielm*")
            (progn
              (split-window-sensibly (selected-window))
              (other-window 1)
              (ielm)))
          (ielm-change-working-buffer buf)))
    #+end_src

    Press =C-c M-:= to start IELM with current buffer
    #+begin_src emacs-lisp
      (bind-key "C-c M-:" 'ffy-ielm)
    #+end_src


** Clojure

   #+begin_src emacs-lisp
     (use-package clojure-mode
       :ensure t
       :init (progn
               (mapc (apply-partially 'add-hook 'clojure-mode-hook)
                     '(ffy-find-file-in-clojure-project
                       subword-mode
                       enable-paredit-mode
                       turn-on-hl-line-mode
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       local-column-number-mode
                       local-comment-auto-fill
                       turn-on-eldoc-mode
                       rainbow-delimiters-mode-enable))))
     (use-package elein
       :ensure t)
   #+end_src

   #+begin_src emacs-lisp
     (defun ffy-find-file-in-clojure-project ()
       "For Clojure we are also looking for project.clj file in the project root"
       (progn
         (require 'find-file-in-project)
         (when (boundp 'ffip-project-file)
           (set (make-local-variable 'ffip-project-file)
                (if (listp 'ffip-project-file)
                    (cons "project.clj" ffip-project-file)
                  (list "project.clj" ffip-project-file))))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package cider
       :ensure t
       :init (progn
               (mapc (apply-partially 'add-hook 'cider-mode-hook)
                     '(cider-turn-on-eldoc-mode))
               (mapc (apply-partially 'add-hook 'cider-repl-mode-hook)
                     '(subword-mode
                       turn-on-eldoc-mode
                       enable-paredit-mode
                       turn-off-show-trailing-whitespace))
               (add-to-list 'company-backends 'cider-complete-at-point)
               (bind-key "<M-return>" 'reindent-then-newline-and-indent  lisp-mode-shared-map)
               (bind-key "C-x x" 'eval-print-last-sexp  lisp-mode-shared-map)))
   #+end_src

** Ruby/Rails setup
   Loading  Ruby and Rails relate ELPA packages
   #+begin_src emacs-lisp
     (use-package ruby-mode
       :ensure t
       :init (progn
               (use-package rinari
                 :ensure t
                 :config
                 (global-rinari-mode 1))
               (use-package rspec-mode :ensure t)
               (use-package ruby-compilation :ensure t)
               (use-package ruby-electric :ensure t)
               (use-package ruby-end
                 :ensure t
                 :config (progn
                           (defalias 'ruby-insert-end 'ruby-end-insert-end)))
               (use-package rvm :ensure t)
               (use-package yari :ensure t)

               (defun ffy-insert-ruby-string-interpolation ()
                 "In a double quoted string, interpolation is inserted on #."
                 (interactive)
                 (insert "#")
                 (when (and
                        (looking-back "\".*")
                        (looking-at ".*\""))
                   (insert "{}")
                   (backward-char 1)))
               )
       :config (progn
                 (bind-key "<return>" 'reindent-then-newline-and-indent ruby-mode-map)
                 (bind-key "#" 'ffy-insert-ruby-string-interpolation  ruby-mode-map)
                 (bind-key "C-h r" 'yari  ruby-mode-map)
                 (mapc (apply-partially 'add-hook 'ruby-mode-hook)
                       '(subword-mode
                         ruby-electric-mode
                         local-column-number-mode
                         local-comment-auto-fill
                         turn-on-hl-line-mode
                         turn-on-fic-mode
                         turn-on-flyspell-prog-mode
                         inf-ruby-minor-mode)))
       :mode (("\\.rb$" . ruby-mode)
              ("\\.rake$" . ruby-mode)
              ("\\.gemspec$" . ruby-mode)
              ("\\.ru$" . ruby-mode)
              ("Rakefile$" . ruby-mode)
              ("Gemfile$" . ruby-mode)
              ("Capfile$" . ruby-mode)
              ("Guardfile$" . ruby-mode)))
   #+end_src


** YAML
   This is closely related to Ruby/Rails
   #+begin_src emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode (("\\.ya?ml$" . yaml-mode)))
   #+end_src



** HAML/SCSS/SASS setup
   Closely related to Ruby/Rails development

   #+begin_src emacs-lisp
     (use-package haml-mode
       :ensure t
       :commands haml-mode
       :mode ("\\.haml$" . haml-mode))

     ;;; custom line opening
     (defun ffy-open-line-indented (n)
       "like `open-line' but keeps indentation"
       (interactive "*p")
       (let* ((loc (point-marker)))
         (newline-and-indent)
         (goto-char loc)))

     (use-package scss-mode
       :ensure t
       :defer t
       :commands scss-mode
       :mode ("\\.scss$" . scss-mode)
       :init (progn
               ;; my own customizations
               (defun ffy-customize-sass-scss-mode ()
                 (interactive)
                 ;; first of all <ret> sets newline and indent as C-j
                 (local-set-key [return] 'newline-and-indent)
                 (local-set-key [(control return)] 'ffy-open-line-indented))
               (use-package sass-mode
                 :ensure t
                 :defer t
                 :commands sass-mode
                 :mode ("\\.sass$" . sass-mode)
                 :config (progn
                           (mapc (apply-partially 'add-hook 'sass-mode-hook)
                                 '(local-column-number-mode
                                   local-comment-auto-fill
                                   turn-on-hl-line-mode
                                   turn-on-fic-mode
                                   turn-on-flyspell-prog-mode
                                   ffy-customize-sass-scss-mode))))

               (mapc (apply-partially 'add-hook 'scss-mode-hook)
                     '(local-column-number-mode
                       local-comment-auto-fill
                       turn-on-hl-line-mode
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       ffy-customize-sass-scss-mode))))

     ;;; add Auto-Complete HAML SCSS and SASS modes
     ;(dolist (mode '(haml-mode sass-mode scss-mode))
     ;  (add-to-list 'ac-modes mode))
   #+end_src


** Coffee-Script
   #+begin_src emacs-lisp
     (use-package coffee-mode
       :ensure t
       :defer t
       :commands coffee-mode
       :mode ("\\.coffee$" . coffee-mode))
   #+end_src


** JavaScript
   Good link about setting up JavaScript:
   - [[http://blog.deadpansincerity.com/2011/05/setting-up-emacs-as-a-javascript-editing-environment-for-fun-and-profit/][Setup Emacs as a JavaScript IDE For Fun and Profit]]

*** Rhino
**** Setup Rhino
       - On Windows:
         + Download rhino1_7R4.zip from Mozilla page.
         + Unpack it and copy js.jar to =%JRE_HOME%\lib\ext=

       - On Mac OS X:
         + Download rhino and unzip it
         + Make a the library directory if it doesn't exist:
           #+begin_example
            mkdir -p ~/Library/Java/Extensions
           #+end_example

         + Copy the jar to the extensions directory:
           #+begin_example
            cp ~/Downloads/rhino1_7R2/js.jar ~/Library/Java/Extensions/
           #+end_example

**** Running Rhino

     Run the following command:
     #+begin_example
       java org.mozilla.javascript.tools.shell.Main
     #+end_example


*** Setup Emacs

    Make sure =node.js= and =npm= are installed.

    Install =jshint=, =jslint= and =tern= using =npm=

**** Using JS3 Mode                                                     :off:
     :PROPERTIES:
     :tangle:   no
     :END:

    #+begin_src emacs-lisp
      (use-package js3-mode
        :ensure t
        :config (progn
                  (defun js3-mode-configuration ()
                    (setq js3-auto-indent-p t
                          js3-curly-indent-offset 0
                          js3-enter-indents-newline t
                          js3-expr-indent-offset 2
                          js3-indent-on-enter-key t
                          js3-lazy-commas t
                          js3-lazy-dots t
                          js3-lazy-operators t
                          js3-paren-indent-offset 2
                          js3-square-indent-offset 4))

                  (add-hook 'js3-mode-hook 'js3-mode-configuration)
                  (add-hook 'js3-mode-hook 'turn-on-eldoc-mode)
                  (add-hook 'js3-mode-hook 'turn-on-electric-mode)
                  (add-hook 'js3-mode-hook 'hs-minor-mode)))
    #+end_src

**** Using JS2 Mode
     Necessary tools initialization:
     - =tern-mode=
     - =swank.js=

     Add Swank-js from http://www.idryman.org/blog/2013/03/23/installing-swank-dot-js/
     Install Swank.js by
     #+begin_example
        npm install -g swank-js
     #+end_example

     Test by running

     #+begin_example
        swank-js
     #+end_example

     And directing browser to http://localhost:8009/swank-js/test.html

   #+begin_src emacs-lisp
     (use-package js2-mode
       :ensure t
       :mode "\\.js\\'"
       :interpreter "node"
       :init  (progn
                (setq-default js2-basic-offset 2
                              js2-bounce-indent-p nil))

       :config (progn
                 (mapc (apply-partially 'add-hook 'js2-mode-hook)
                       '(js2-imenu-extras-mode
                         imenu-add-menubar-index
                         flycheck-mode
                                             ;turn-on-electric-mode
                         ))))

     (use-package js-comint
       :ensure t
       :config (setq inferior-js-program-command "node --interactive"))

   #+end_src

   Additional packages:
   - =js-doc=
   - =json-mode=
   - =js2-refactor=

   Configure =tern.js=

   #+begin_src emacs-lisp
     (use-package tern
       :ensure t
       :config (progn (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
                      (add-hook 'tern-mode-hook
                                (lambda ()
                                  "Changes tern command for the tern-mode"
                                  (setq-default tern-command '("tern"))))))
   #+end_src

   and autocompletion using =company-tern=

   #+begin_src emacs-lisp
     (use-package company-tern
       :ensure t
       :config (progn

                 (defun ffy-company-js ()
                   "Localizes and modifies COMPANY-BACKENDS for the Javascript buffer"
                   (set (make-local-variable 'company-backends)
                        '((company-tern company-semantic company-capf company-yasnippet)))
                   (company-mode t))

                 (add-hook 'js2-mode-hook #'ffy-company-js)))
   #+end_src

   Good package for remote debugging in the browser is =jss=. Read
   more at https://github.com/segv/jss
   #+begin_src emacs-lisp
     (use-package jss
       :disabled t
       :ensure t
       :defer t)
   #+end_src


** Octave Mode
   #+begin_src emacs-lisp
     (setq auto-mode-alist
           (cons '("\\.m$" . octave-mode) auto-mode-alist))
     (add-hook 'octave-mode-hook (lambda ()
                                   (auto-fill-mode 1)))
   #+end_src


** Haskell Mode

   The easiest way to start with Haskell is to install Haskell
   Platform. The caveat here is that GHC is a little bit old.

   #+begin_src emacs-lisp
     (use-package haskell-mode
       :ensure t
       :init (progn
               (mapc (apply-partially 'add-hook 'haskell-mode-hook)
                     '(local-column-number-mode
                       local-comment-auto-fill
                       turn-on-hl-line-mode
                       pretty-greek
                       turn-on-fic-mode
                       turn-on-flyspell-prog-mode
                       ;; turn-on-flymake
                       turn-on-haskell-doc-mode
                       ;; turn-on-haskell-indent
                       turn-on-haskell-indentation
                       interactive-haskell-mode))))
   #+end_src

   To provide navigation to definitions we need to install =hasktags=
   via =cabal install hasktags= into a global.

   #+begin_src emacs-lisp
     (when (executable-find "hasktags")
       (custom-set-variables
        '(haskell-tags-on-save t)))
   #+end_src

   To provide addition functionality we install =ghc-mod= package
   using cabal, if it is not installed yet =cabal install ghc-mod=.

   If you use GHC version 7.8 and later, then chances are you have
   some of the functionality already there (such as =:complete=)

   For auto-completion there's a package =company-ghc=
   (https://github.com/iquiw/company-ghc). It will also install =ghc=
   package as a dependency

   #+begin_src emacs-lisp
     (use-package company-ghc
       :ensure t
       :init (progn
               ;; add as a company back-end
               (add-to-list 'company-backends 'company-ghc)
               (add-hook 'haskell-mode-hook 'ghc-init)))
   #+end_src

   More details on =ghc-mod= and emacs =ghc= package are available at
   http://www.mew.org/~kazu/proj/ghc-mod/en/

   Interesting configurations to look at:
   - https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el
   - https://github.com/serras/emacs-config-2/blob/master/haskell.el

   Configuration tutorial at
   https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

   
   Keys:
   - =M-RET= add import
   - =M-t= add signature to the function missing it.

   
*** GHCi

    Interpreter in haskell is available at =C-c C-l= but only in
    Cabal projects.

    Install =hoogle= package to search for the Haskell code and
    documentation in the libraries.

    Installing hoogle on Mac OS X with GHC 7.6.3 (the one from
    Haskell Platform ) will most likely fail due to the bug in
    compiler. It manifests itself as an error while installing
    =conduit= package (error itself described here :
    https://github.com/snoyberg/conduit/issues/147 ). To fix it one
    needs to put a wrapper for llvm preprocessor. Details are here
http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9.
    However binary wrapper is not available anymore. To fix it using
    bash script go here: https://www.haskell.org/platform/mac.html
    In short, it will patch haskell platfor (settings file) to make
    it work with clang.

    After installing =hoogle=, add call to hoogle to ghci (see
    http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration).

    If command line works then it will also work =haskell-mode=,
    check variable =haskell-hoogle-command=


** Python
   On Mac to use Python one should use MacPorts then one could see
   available pythons via =port select --list python=. To activate
   python use =sudo port select --set python python27=. Install =pip=
   using MacPorts, =sudo port install py-pip=. If installation fails
   run =clean= command and repeat. It should install =pip= for
   appropriate version of Python (the one that has been activated).

   When =pip= is installed using =get-pip.py= script it fails to
   install some packages, probably because of missing deps.

   #+begin_src emacs-lisp
     (use-package python
       :config
       (let ((ipython (executable-find "ipython")))
         (if ipython
             (setq python-shell-interpreter ipython)
           (warn "No IPython Found"))))
   #+end_src

   Completion and navigation is done using ~anaconda~. Install it
   using ~pip install anaconda_mode~

   #+begin_src emacs-lisp
     (use-package anaconda-mode
       :ensure t
       :init (add-hook 'python-mode-hook #'anaconda-mode))

     (use-package company-anaconda
       :ensure t
       :init (with-eval-after-load 'company
               (add-to-list 'company-backends 'company-anaconda)))
   #+end_src



** C/C++

   Writing C/C++ programs.
   Good source of information [[http://tuhdo.github.io/c-ide.html]]

   #+begin_src emacs-lisp
     (use-package cc-mode
       :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
              ("\\.m\\'"                   . c-mode)
              ("\\.mm\\'"                  . c++-mode))
       )
   #+end_src

   Using =company-c-headers=. By default, it adds only C headers.
   Adding C++ paths needs to be manual and system dependent. In its
   easiest form figuring out what are the paths is as easy as =g++
   -v=. More information about preprocessors paths could be found at
   https://gcc.gnu.org/ml/gcc-help/2007-09/msg00206.html


   Location of header files for C/C++ (perhaps, one thing to do is to
   make it system specific).

   #+begin_src emacs-lisp
     (setq ffy-c-headers-locations '("/usr/include/c++/4.2.1"
                                     "C:/PF86/LLVM/lib/clang/3.6.2/include"
                                     "C:/PF86/LLVM/i686-w64-mingw32/include"
                                     "C:/PF86/LLVM/i686-w64-mingw32/include/c++"
                                     "C:/PF86/LLVM/i686-w64-mingw32/include/c++/i686-w64-mingw32"
                                     "C:/PF86/LLVM/include/"))
   #+end_src


   On Mac OS X after 10.8 =g++= is actually a =clang=.
   Another way is =cpp -Wp -v=

   Finding paths with Clang =clang -E -x c++ -v test.c=

   #+begin_src emacs-lisp
     (use-package company-c-headers
       :ensure t
       :config (progn
                 (add-to-list 'company-backends 'company-c-headers)
                 (dolist (dir ffy-c-headers-locations)
                   (add-to-list 'company-c-headers-path-system dir))))
   #+end_src

   Configuring Clang and Mingw on Windows
   https://yongweiwu.wordpress.com/2014/12/24/installing-clang-3-5-for-windows/

   Adding =c-eldoc= (not from MELPA but from my repo)

   #+begin_src emacs-lisp
     (use-package c-eldoc
       :config (setq c-eldoc-includes
                     (mapconcat #'identity
                                ;; on Windows `pkg-config` .... leads to an
                                ;; error
                                (cons ;c-eldoc-includes
                                      "-I. -I.."
                                      (mapcar (apply-partially #'concat "-I")
                                              ffy-c-headers-locations))
                                " ")
                     c-eldoc-cpp-command "cpp"))
   #+end_src

   =cc-mode= has a bug that makes =c-mode-hook= run twice
   (http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16759). This is some
   defensive programming.

   #+begin_src emacs-lisp
     (defun ffy-c-mode-hook ()
       "This is settings for the C/C++ mode"
       (when (memq major-mode '(c-mode c++-mode))
         (electric-pair-mode +1)
         (electric-indent-local-mode +1)
         (c-toggle-hungry-state +1)
         (c-set-style "gnu")
         (setq c-basic-offset 4)
         (set (make-local-variable 'compile-command)
              (let ((f (file-name-nondirectory (buffer-file-name))))
                (case major-mode
                  ('c-mode (format "gcc -g -O2 -std=gnu99 -static -lm %s" f))
                  ('c++-mode (format "g++ -g -O2 -static -std=gnu++11 %s" f))
                  (t compile-command))))))
     ;;; due to a bug http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16759 we
     ;;; add it to a c-mode-common-hook
     (add-hook 'c-mode-common-hook #'ffy-c-mode-hook)
   #+end_src


** Golang

   Installation is just download distribution and correct =PATH= and
   =GOPATH= environment variables.

   Some of the helpful tools to install
   - =goimports= To automatically resolve imports and formatting
     =go get golang.org/x/tools/cmd/goimports=
   - =gocode=  For autocompletion and eldoc functionality
     =go get github.com/nsf/gocode=
   - =godef= to navigate code/definitions
     =go get github.com/rogpeppe/godef=


   #+begin_src emacs-lisp
     (use-package go-mode
       :ensure t
       :init (progn
               (use-package go-eldoc
                 :ensure t
                 :config
                 (add-hook 'go-mode-hook 'go-eldoc-setup))
               (use-package company-go
                 :ensure t
                 :init (progn
                         (add-to-list 'company-backends 'company-go)))
               (defun go-run-buffer ()
                 "This will run buffer on the Go"
                 (interactive)
                 (compile (concat "go run " (buffer-file-name))))

               (add-hook 'go-mode-hook (lambda ()
                                         ;; customize  compile command for go-mode
                                         (set (make-local-variable 'compile-command)
                                              "go build")
                                         ;; make before-save-hook local for go-mode buffer
                                         (add-hook 'before-save-hook 'gofmt nil t))))
       :config (progn
                 (setq gofmt-command "goimports")
                 (bind-key "C-c C-f" 'gofmt go-mode-map)
                 (bind-key "C-c ?"  'godoc-at-point go-mode-map)
                 (bind-key "C-c d" 'godoc go-mode-map)
                 (bind-key "C-c C-r" 'go-run-buffer go-mode-map)))
   #+end_src

   Other things to look at:
   - =go-oracle= ([[https://docs.google.com/document/d/1SLk36YRjjMgKqe490mSRzOPYEDe0Y_WQNRv-EiFYUyw/view][Documentation]]).




** Modes for specific files
   For getting the text content of the word documents:

   #+begin_src emacs-lisp
     (when (executable-find "docx2txt")
       (add-to-list 'auto-mode-alist '("\\.docx\\'" . docx2txt))

       (defun docx2txt ()
         "Run docx2txt on the entire buffer."
         (shell-command-on-region (point-min) (point-max) "docx2txt" t t)))
   #+end_src

   Mercurial settings are edited using =conf-mod=
   #+begin_src emacs-lisp
     (dolist (pattern '("\\.hgrc\\'"
                        "\\.hg/hgrc\\'"
                        "Mercurial\\.ini\\'"))
       (add-to-list 'auto-mode-alist (cons pattern 'conf-mode)))
   #+end_src

* Finally

  Load custom variables and faces from the customization file
  #+begin_src emacs-lisp
    (setq custom-file (concat *dotfiles-dir* "custom.el"))
    (load custom-file 'noerror)
  #+end_src

  Each workstation I work on has some specific details that are
  described in the file for that machine. They are stored in the
  machine specific folder =systems=. Loading machine specific settings:

  #+begin_src emacs-lisp
    (let ((system-specific-config (concat *system-specific* system-name ".el")))
      (if (file-exists-p system-specific-config)
          (load system-specific-config)))
  #+end_src

  How long did it take to load?

  #+begin_src emacs-lisp
    (let ((elapsed (float-time (time-subtract (current-time)  *emacs-start-time*))))
      (message "Loading Emacs...done (%.3fs)" elapsed))
  #+end_src
