#+title: Emacs Configuration
#+author: Evgeniy Sharapov
#+email: evgeniy.sharapov@gmail.com

* Introduction
  Configuration works with Emacs 24.5

  =init.el= file is kept to the bare minimum - just load the
  =org-babel= and then go to the =configuration.org=.

  By default all =src= blocks with Emacs Lisp are _tangled_. That is
  all of them will go into =configuration.el= file that gets loaded.
  One can turn off a particular bit by adding =:tangle no= to an =src=
  block header. Or setting a property for  a whole subtree. For
  instance by pressing =C-c C-x p= or by calling =org-set-property=.

* Initialization
** Benchmark
   We always want to start up as fast as possible. Hence we need to
   measure this most important KPI at the start.

   #+begin_src emacs-lisp
     (defconst *emacs-start-time* (current-time))
   #+end_src

** Paths Configuration
*** Constants for Paths
    Instead of string literals in file path related code we will use
    these named constants.

    #+begin_src emacs-lisp
      (defconst *dotfiles-dir*
        (file-name-directory (or (buffer-file-name) load-file-name))
        "Directory for dot files of Emacs configuration, i.e. path to .emacs.d directory")
      (defconst *site-lisp*
        (file-name-as-directory (concat *dotfiles-dir* "site-lisp"))
        "Directory for Emacs Extensions files")
      (defconst *elpa-dir*
        (file-name-as-directory (concat *dotfiles-dir* "elpa"))
        "Directory for ELPA packages")
      (defconst *data-dir*
        (file-name-as-directory (concat *dotfiles-dir* "data"))
        "Directory for miscellaneous data, s.a. backups, histories and caches")
      (defconst *backup-dir*
        (file-name-as-directory (concat *data-dir* "backups"))
        "Directory for backups")
      (defconst *autoload-file*
        (concat *dotfiles-dir* "loaddefs.el")
        "This is file containing all autoloads extracted from Emacs lisp files")
      (defconst *system-specific*
        (file-name-as-directory (concat *dotfiles-dir* "systems"))
        "Directory with system specific initialization commands")
    #+end_src


*** Add =*site-lisp*= Recursively to =load-path=
    Adding files from =.emacs.d= to the load path

    Add recursively all subdirectories of =*site-lisp*=. I could have
    done it using temporary recursive function created via
    =cl-labels=. But at this point we don't have CL loaded, so I
    will do that using =fmakunbound=. The whole point is
    not to clutter function space.

    #+begin_src emacs-lisp
       ;;; create recursive function
       (defun add-directory-to-path (dir)
         (add-to-list 'load-path dir)
         (dolist (entry (directory-files-and-attributes dir))
           (if (and (cadr entry) ; t for directory
                    (not (member (car entry) '("." "..")))) ; we don't want to deal with . and ..
               (let ((new-directory (expand-file-name (car entry) dir)))
                 (add-to-list 'load-path new-directory)
                 (add-directory-to-path new-directory)))))
       ;;; add the directory tree
       (add-directory-to-path *site-lisp*)
       ;;; erase the function
       (fmakunbound #'add-directory-to-path)
    #+end_src

** Package Manager
   ELPA is in between setting up paths and loading up libraries. So
   we put it right in between.
   #+begin_src emacs-lisp
     (setq package-user-dir (concat *dotfiles-dir* "elpa")
           package-archives '(("gnu"          . "http://elpa.gnu.org/packages/")
                              ("melpa-stable" . "http://stable.melpa.org/packages/")
                              ("melpa"        . "http://melpa.org/packages/")))
   #+end_src

   This is a workaround for a bug in emacs' http fetching, see
   http://lists.gnu.org/archive/html/bug-gnu-emacs/2011-12/msg00196.html

   #+begin_src emacs-lisp
     (setq url-http-attempt-keepalives nil)
   #+end_src

** Loading Packages and Libraries
*** Loading Emacs built-in libraries
    Some of the libraries and packages that come with Emacs are so
    useful that we use them in this configuration file. Hence we will
    load them right away.

    We are trying to explicitly load as few libraries as possible.

    #+begin_src emacs-lisp
      (mapc #'require '(uniquify saveplace))
    #+end_src

    We use some of the CL functions for its convenience =cl-labels=,
    =cl-remove-if= and =cl-loop=. Hence we need to load =cl=
    library.

    #+begin_src emacs-lisp
      (require 'cl-lib)
    #+end_src

*** Loading =use-package= and =bind-key=

    We manage packages and libraries through =use-package=. So it has
    to be loaded up. However, since we have it as a Git module it may
    not be available in the freshly cloned repository. If it can't be
    loaded we should run in the command line:

    #+begin_src sh
      git submodule update --init
    #+end_src

    from the =~/.emacs.d= directory (or whatever other name could be).

   #+begin_src emacs-lisp
     (unless (require 'use-package nil 'noerror)
        (let ((default-directory (file-name-directory load-file-name)))
              (shell-command "git submodule update --init"))
        (message "Updated use-package libraries"))
     (mapc #'require '(use-package bind-key))
   #+end_src

** Notes on Windows
   Make sure that you have following DLL libraries in you =Emacs/bin=
   directory:
   - libcharset.dll
   - libiconv.dll
   - libxml2.dll
   - libXpm.dll
   - zlib1.dll

  You can download them from: http://xmlsoft.org/sources/win32/64bit/

** Utility Functions

   #+begin_src emacs-lisp
     (defun ffy-add-hooks (hook &rest functions)
       "Like `add-hook' method but can add multiple FUNCTIONS to a HOOK"
       (mapc (apply-partially 'add-hook hook) functions))
   #+end_src

* Key Bindings Setup
** Overview
    Approach to the key binding is laid out below:

    + =C-x= primary map (some defaults)
    + =C-c= secondary map (modes use it)
    + =C-z= tertiary map =ctl-z-map= (private custom one)
      Borrowed this idea from http://www.jurta.org/en/emacs/dotemacs
      Make the prefix key =C-z= for my personal keymap.  On
      qwerty-keyboards =C-z= is one of the most accessible keys like
      =C-x= and =C-c=, but the prefix key =C-c= is reserved  for
      mode-specific commands (both user-defined and standard Emacs
      extensions). The standard binding of =C-z= (=suspend-emacs= or
      =iconify-or-deiconify-frame=) is reassigned here to double key
      sequence =C-z C-z=.
      #+begin_src emacs-lisp
        (defvar ctl-z-map)
        (define-prefix-command 'ctl-z-map)
        (let ((c-z (global-key-binding [(control ?z)])))
          (global-unset-key [(control ?z)])
          (bind-key "C-z" 'ctl-z-map)
          (bind-key "C-z C-z" c-z))
      #+end_src

    The sequence continues with quaternary, quinary, senary,
    septenary, octonary, nonary, and denary, although most of these
    terms are rarely used. There's no word relating to the number
    eleven but there is one that relates to the number twelve:
    duodenary.

** Possible Key Bindings
   Some of the more or less possible key binding could be:
   - =C-<capital letter>=
   - =M-<capital letter>=
   - =C-M-<capital letter>=

   Single-letter bindings:
   - =C-= ":<>|!$%^*~=
   - =M-= "#+
   - =M-C-= '"=+()[]{}*&^$#!`~

   Following keys are easy to press with one hand:
   =M-f12=, =M-f11=, =M-f10=, =M-f9=, =M-f8=, =M-f7=

** Custom Keymaps
    + =C-x f=  - file operations map
      #+begin_src emacs-lisp
        (bind-keys :prefix-map ctl-x-f-map
                   :prefix "C-x f"
                   :prefix-docstring "File operations map")
      #+end_src
    + =M-g=    - goto map (already exists in Emacs24)
    + =C-x t=  - toggling map
      #+begin_src emacs-lisp
        (bind-keys :prefix-map ctl-x-t-map
                   :prefix "C-x t"
                   :prefix-docstring "Toggle map")
      #+end_src

    + =C-x w=  - window operations keymap
      #+begin_src emacs-lisp
        (bind-keys :prefix-map ctl-x-w-map
                   :prefix "C-x w"
                   :prefix-docstring "Window operations map")
      #+end_src

** Remapping standard commands

   I rarely want to suspend Emacs but almost always hit suspend
   instead of repeat command so =repeat= is both =C-x z= and =C-x C-z=

   #+begin_src emacs-lisp :tangle yes
     (let ((c-x-z (global-key-binding [(control x) ?z])))
       (global-unset-key [(control x) (control ?z)])
       (define-key ctl-x-map [(control ?z)] c-x-z))
   #+end_src

** TODO Key Binging To Change:
   - change =M-o= from =facemenu-keymap= to =outline-mode= keymap  =M-o=
   - change =M-f10= from =toggle-frame-maximized=

* General Settings
** User Interface
*** Appearance

    Turn off menu bar, scroll bars and tool bar.
     #+begin_src emacs-lisp
       (custom-set-minor-mode 'menu-bar-mode nil)
       (custom-set-minor-mode 'tool-bar-mode nil)
       (custom-set-minor-mode 'scroll-bar-mode nil)
     #+end_src

     File name into the frame title
     #+begin_src emacs-lisp
       (when (display-graphic-p)
         (setq frame-title-format '(buffer-file-name "%f" ("%b")))
         (mouse-wheel-mode t)
         (blink-cursor-mode -1))
     #+end_src

*** Modeline Configuration

    Display time in mode-line
    #+begin_src emacs-lisp
       (display-time)
    #+end_src

    Modeline is configured using =powerline= package and =diminish=
    mode to hide information about some of the modes

    #+begin_src emacs-lisp
      (use-package diminish
        :ensure t
        :defer t)
      (use-package powerline
        :ensure t
        :config (progn
                  (defun ffy-powerline-theme ()
                    "Powerline setup for the mode-line."
                    (interactive)
                    (setq-default mode-line-format
                                  '("%e"
                                    (:eval
                                     (let* ((active (powerline-selected-window-active))
                                            (mode-line (if active 'mode-line 'mode-line-inactive))
                                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                                            (separator-left (intern (format "powerline-%s-%s"
                                                                            powerline-default-separator
                                                                            (car powerline-default-separator-dir))))
                                            (separator-right (intern (format "powerline-%s-%s"
                                                                             powerline-default-separator
                                                                             (cdr powerline-default-separator-dir))))
                                            (lhs (list (powerline-raw "%*" nil 'l)
                                                       (powerline-buffer-size nil 'l)
                                                       (powerline-raw mode-line-mule-info nil 'l)
                                                       (powerline-buffer-id nil 'l)
                                                       (when (and (boundp 'which-func-mode) which-func-mode)
                                                         (powerline-raw which-func-format nil 'l))
                                                       (powerline-raw " ")
                                                       (funcall separator-left mode-line face1)
                                                       (when (boundp 'erc-modified-channels-object)
                                                         (powerline-raw erc-modified-channels-object face1 'l))
                                                       (powerline-major-mode face1 'l)
                                                       (powerline-process face1)
                                                       (powerline-minor-modes face1 'l)
                                                       (powerline-narrow face1 'l)
                                                       (powerline-raw " " face1)
                                                       (funcall separator-left face1 face2)
                                                       (powerline-vc face2 'r)))
                                            (rhs (list (powerline-raw global-mode-string face2 'r)
                                                       (funcall separator-left face2 face1)
                                                       (powerline-raw "%4l" face1 'l)
                                                       (powerline-raw ":" face1 'l)
                                                       (powerline-raw "%3c" face1 'r)
                                                       (funcall separator-right face1 face2)
                                                       (powerline-raw " ")
                                                       (powerline-raw "%6p" nil 'r)
                                                       (powerline-hud face2 face1))))
                                       (concat (powerline-render lhs)
                                               (powerline-fill face2 (powerline-width rhs))
                                               (powerline-render rhs)))))))

                  (ffy-powerline-theme)
                  ;(powerline-default-theme)
                  (add-hook 'desktop-after-read-hook 'powerline-reset)
                  ))

    #+end_src

*** Menu bar
    Turn on the menu bar for exploring new modes
    #+begin_src emacs-lisp
      (bind-keys :map ctl-x-t-map
                 ("m" . menu-bar-mode)
                 ("i" . imenu-add-menubar-index))
    #+end_src

*** TypeFaces and Fonts
    Typefaces and fonts are important. Here are some favorites:

    #+begin_src emacs-lisp
      (setq ffy-type-faces '("DejaVu LGC Sans Mono"
                             "Consolas"
                             "Source Code Pro"
                             "Monaco"
                             "Menlo"
                             "Meslo LG L DZ"
                             "Meslo LG M DZ"
                             "Meslo LG S DZ"
                             "Bitstream Vera Sans Mono"
                             "Anonymous Pro"
                             "Inconsolata LGC"
                             "Envy Code R"
                             "PragmataPro"
                             "Pragmata TT"
                             "NotCourierSans"
                             "Liberation Mono"
                             "Hack"
                             "Fira Code"
                             "Code New Roman"
                             "Audimat Mono:light"
                             "CamingoCode"
                             "Input"
                             "IosevkaCC"
                             "Iosevka"
                             "mononoki"
                             "Monoid"
                             "Lucida Console"
                             "M+ 1mn"
                             "M+ 1m"
                             "M+ 1c"
                             "M+ 1p"
                             "M+ 2mn"
                             "M+ 2m"
                             "M+ 2c"
                             "M+ 2p"))
    #+end_src

    Setting font as a frame font

    #+begin_src emacs-lisp
      (defun ffy-select-typeface ()
        "Choose typefaces for the frame"
        (interactive)
        (set-frame-font (ido-completing-read+ "Choose font:" ffy-type-faces nil nil) t))

      (bind-key "f" #'ffy-select-typeface ctl-x-t-map)
    #+end_src


    Links to the fonts pages:
    - Inconsolata: http://www.levien.com/type/myfonts/inconsolata.html
    - Monospaced, Coding, Programming Fonts:
      http://www.1001fonts.com/monospaced+coding+programming-fonts.html
    - Programmer's Fonts: http://www.lowing.org/fonts/
    - Top 10 Programmer's Fonts:
      http://hivelogic.com/articles/top-10-programming-fonts/
    - Programmer's Font Comparison: https://s9w.github.io/font_compare/
    - Anonymous Pro:
      http://www.marksimonson.com/fonts/view/anonymous-pro
    - Programming Fonts: http://programmingfonts.org/
    - Iosevka: https://be5invis.github.io/Iosevka/
    - Input: http://input.fontbureau.com/
    - M+ font: http://mplus-fonts.osdn.jp/index.html
    - Monnoki: http://madmalik.github.io/mononoki/
    - Proggy: http://www.proggyfonts.net/
    - FiraCode: https://github.com/tonsky/FiraCode
    - Consolamono: https://fontlibrary.org/en/font/consolamono
    - Audimat-Mono: https://www.fontsquirrel.com/fonts/Audimat-Mono
    - Anka-Coder-Fonts: https://github.com/fitojb/anka-coder-fonts
    - NotCourierSans: https://fontlibrary.org/en/font/notcouriersans

** Files/Directories
*** Backups and saves
    #+begin_src emacs-lisp
            (setq save-place-file (concat *data-dir* "places")
                  backup-directory-alist `((".*" . ,*backup-dir*))
                  savehist-file (concat *data-dir* "history")
                  recentf-save-file (concat *data-dir* ".recentf")
                  ido-save-directory-list-file (concat *data-dir* ".ido.last")
                  bookmark-default-file (concat *data-dir* "bookmarks")
                  desktop-dirname *data-dir*
                  desktop-path (list desktop-dirname)
                  desktop-save t
                  auto-save-list-file-prefix (concat *data-dir* "auto-save-list/.saves-")
                  abbrev-file-name (concat *data-dir* "abbrev_defs"))
    #+end_src

    Desktop mode allows to save/open files from the previous Emacs
    session. We set the hook that would re-read Emacs desktop file at
    the end. We execute =desktop-read= in the initialization part in
    =after-init-hook= (see =init.el=).

*** Configuration Files
    #+begin_src emacs-lisp
      (setq url-configuration-directory (file-name-as-directory (concat *data-dir* "url")))
    #+end_src

*** Files and Projects
    #+begin_src emacs-lisp
      (use-package find-file-in-project
        :ensure t
        :commands find-file-in-project
        :config (setq ffip-prefer-ido-mode t
                      ffip-match-path-instead-of-filename t))
    #+end_src

    Opening files from =recentf= list

    #+begin_src emacs-lisp
      (defun ido-choose-from-recentf ()
        "Use ido to select a recently opened file from the `recentf-list'"
        (interactive)
        (find-file (ido-completing-read "Open file: " recentf-list nil t)))
    #+end_src

    Using Projectile
    #+begin_src emacs-lisp
      (use-package projectile
        :ensure t
        :defer 5
        :diminish projectile-mode
        :commands projectile-global-mode
        :init
        (setq projectile-cache-file (expand-file-name "projectile.cache" *data-dir*)
              projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" *data-dir*)
              projectile-sort-order 'recentf
              projectile-indexing-method 'alien)
        :config
        (projectile-global-mode t))
    #+end_src

*** Files Key-Bindings

    =C-x C-f= is bound to =ido-find-file=
    =C-x f <letter>= are different file commands

    #+begin_src emacs-lisp
      (bind-key  "R"   'recentf-open-most-recent-file ctl-x-f-map)
      (bind-key  "o"   'ido-find-file-other-window    ctl-x-f-map)
      (bind-key  "f"   'find-file-in-project          ctl-x-f-map)
      (bind-key  "r"   'ido-choose-from-recentf       ctl-x-f-map)
      (bind-key  "RET" 'find-file-at-point            ctl-x-f-map)
    #+end_src

*** Dired
    Here's the list useful keys used in Dired: [[http://harryrschwartz.com/assets/documents/dired-cheatsheet.pdf][Dired Cheat Sheet]].

    - This will make Dired guess where to copy files:
      #+begin_src emacs-lisp
        (setq dired-dwim-target t)
      #+end_src
    - Human friendly listing
      #+begin_src emacs-lisp
        (setq dired-listing-switches  "-alhG" )
      #+end_src
    - List directories first
      #+begin_src emacs-lisp
        (setq ls-lisp-dirs-first t)
      #+end_src
    - Show human sizes of directories
      #+begin_src emacs-lisp
        (setq directory-free-space-args "-Pmh")
      #+end_src


    Switch to "writable" =dired-mode=. It makes it very easy to rename files.
    #+begin_src emacs-lisp
       (add-hook 'dired-mode-hook
                 '(lambda ()
                     (bind-key "W" 'wdired-change-to-wdired-mode dired-mode-map)))
    #+end_src

    Interesting addition to the Dired [[https://github.com/emacs-jp/bf-mode/blob/master/bf-mode.el][Browse-File Mode]]

    =dired-jump-other-window= is bound to =C-x 4 C-j=
    #+begin_src emacs-lisp
      (bind-key "j" #'dired-jump ctl-x-map)
    #+end_src

** Buffers
   Use =ibuffer= for buffer operations

   #+begin_src emacs-lisp
     (use-package ibuffer
       :bind ("C-x C-b" . ibuffer)
       :init (progn
               (defface ibuffer-custom-deletion-face '((t (:inherit error :strike-through t :underline nil))) "Buffers to be deleted")
               (defface ibuffer-custom-marked-face '((t (:inherit warning :inverse-video t :underline nil))) "Marked buffers")
               (setq ibuffer-deletion-face 'ibuffer-custom-deletion-face
                     ibuffer-marked-face 'ibuffer-custom-marked-face
                     ;; don't ask to kill buffers
                     ibuffer-expert t)
               ;; auto updateable ibuffer
               (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode)))
   #+end_src

   Often I need to create temporary buffer

   #+name: ffy-create-temp-buffer
   #+begin_src emacs-lisp
      (defun ffy-create-temp-buffer ()
        "Creates temporary buffer"
        (interactive)
        (switch-to-buffer "*temp* "))
   #+end_src

   Key bindings:

   #+begin_src emacs-lisp
     (bind-keys :prefix-map buffer-operations-map
                :prefix "C-z b"
                :prefix-docstring "Operations on buffers"
                ("y" . bury-buffer)
                ("g" . revert-buffer)
                ("t" . ffy-create-temp-buffer))
     (bind-key "C-x K" 'kill-this-buffer)
     (bind-key "<f5>" 'revert-buffer)
   #+end_src

    Other useful keys:
    - =C-x 4 0= - kill-buffer-and-window (works with current buffer
      only)
    - =C-x 4 b= - ido open buffer other window

** Mini-buffer

    Automatically close certain buffers after exiting from
    mini-buffer
    #+begin_src emacs-lisp
      (defvar *auto-close-buffers* '("*Completions*"
                                     "*Ido Completions*")
        "List of buffers that should be closed after we done with minibuffer. Usually it is various completions buffers")

      (add-hook 'minibuffer-exit-hook
                '(lambda ()
                   (progn
                     (mapc '(lambda (buffer)
                              (if (buffer-live-p buffer)
                                  (kill-buffer buffer))) *auto-close-buffers*))))
    #+end_src

    Use =smex= in the mini-buffer. =M-x= runs command and =M-X= runs
    command for the major mode.

    #+begin_src emacs-lisp
      (use-package smex
        :ensure t
        :init
        (setq smex-save-file (concat *data-dir* ".smex-items")
              smex-history-length 20)
        :config
        (smex-initialize)
        :bind (("M-x" . smex)
               ("M-X" . smex-major-mode-commands)))
    #+end_src

    We are trying to make keys working in both Windows and Mac OS X to
    be able to =M-x= without meta

    #+begin_src emacs-lisp
      (bind-key "C-x C-m"  'execute-extended-command)
    #+end_src

** Windows
    #+begin_src emacs-lisp
      (use-package window
        :bind (:map ctl-x-w-map
               ("D" . delete-window)
               ("M" . delete-other-windows)))
    #+end_src

    Using =Windmove= for switching between windows in Emacs

    #+begin_src emacs-lisp :preamble # -*- coding: utf-8 -*-
      (use-package windmove
        :ensure t
        :defer t
        :bind (:map ctl-x-w-map
                    ("<left>" . windmove-left)
                    ("h" . windmove-left)
                    ("<right>" . windmove-right)
                    ("l" . windmove-right)
                    ("<up>" . windmove-up)
                    ("j" . windmove-up)
                    ("<down>" . windmove-down)
                    ("k" . windmove-down)))
    #+end_src

    For somewhat different navigation between windows use =Ace-Window=

    #+begin_src emacs-lisp
      (use-package ace-window
        :ensure t
        :pin melpa-stable
        :bind ("C-x o" . ace-window))
    #+end_src

    Now since we are using =ace-window= we also get
    - =C-u C-x o= swapping windows
    - =C-u C-u C-x o= delete window

** Help System
   Some of the useful functions and setting dealing with Info system
   in emacs:
   #+begin_src emacs-lisp
     (use-package help-mode+ :ensure t)
     (use-package help+ :ensure t)
     (use-package help-fns+ :ensure t)
   #+end_src

   #+begin_src emacs-lisp
     (bind-keys :map help-map
                ("C-b" . describe-personal-keybindings)
                ("C-k" . describe-key-briefly)
                ("C-c" . describe-char))
   #+end_src

   Some key help

   #+begin_src emacs-lisp
     (use-package which-key
       :ensure t
       :defer 10
       :diminish which-key-mode
       :commands which-key-mode
       :init (setq which-key-sort-order 'which-key-local-then-key-order
                   which-key-max-description-length 32)
       :config
       ;(which-key-mode t)
       (mapc (apply-partially 'add-to-list 'which-key-key-replacement-alist)
             '(("up" . "⇑")
               ("right" . "⇒")
               ("left" . "⇐")
               ("down" . "⇓")))
       (mapc (apply-partially 'add-to-list 'which-key-description-replacement-alist)
             '(("projectile-" . "prj-"))))
   #+end_src


** Spell checker
   We could use Hunspell or Aspell. Hunspell seems to be better for
   spellchecking. Even though it requires building up from the
   source code it is worth it.

   Link to the binary for Windows
   http://sourceforge.net/projects/ezwinports/files/hunspell-1.3.2-3-w32-bin.zip/download

   #+begin_src emacs-lisp
     (use-package flyspell
       :bind-keymap ("C-z i" . flyspell-mode-map)
       :init
       (use-package ispell
         :config (progn
                   ;; Personal dictionary setup
                   ;; if file doesn't exist then create it
                   (setq ispell-personal-dictionary (let ((personal-dictionary-file (concat *data-dir* ".personal.dict")))
                                                      (unless (file-exists-p personal-dictionary-file)
                                                        (with-temp-file personal-dictionary-file t))
                                                      personal-dictionary-file))
                   ;; Aspell Specific
                   (when (executable-find "aspell")
                     (setq ispell-program-name "aspell"
                           ispell-extra-args '("--sug-mode=ultra")))
                   ;; Hunspell Specific
                   (when (executable-find "hunspell")
                     (setq ispell-program-name "hunspell"))
                   )))
   #+end_src

   Some =Hunspell= related settings to a modern emacs (version >=
   24.4) is here
   http://lists.gnu.org/archive/html/help-gnu-emacs/2014-04/msg00030.html

** Miscellaneous
   Here we collect settings and commands that don't really fall into
   any specific category

   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
     (random t)
   #+end_src

** IDO settings
   IDO mode speeds up some of the tasks. Some of the IDO settings that
   have been taken out from the customization file.
   #+begin_src emacs-lisp
     (use-package ido
       :init
       (progn
         (use-package ido-ubiquitous
           :ensure t
           :commands ido-ubiquitous-mode)
         (use-package flx-ido
           :ensure t
           :config (flx-ido-mode t))
         (use-package ido-vertical-mode
           :ensure t
           :init (add-hook 'ido-minibuffer-setup-hook 'turn-off-show-trailing-whitespace)
           :config (ido-vertical-mode t)))
       :config
       (progn
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t)))
   #+end_src

* Editing
** Appearance
   Visual lines mode makes lines longer than window width can be
   displayed so that they are wrapped at word boundary. By default it
   is off and we want it on only for text editing modes, such as
   =latex-mode=, =markdown-mode=, etc. One can call
   =visual-line-mode= to toggle on/off.

   #+begin_src emacs-lisp
     (bind-key "RET" 'visual-line-mode ctl-x-t-map)
   #+end_src


   Visual line mode actually does several things. From a user's point
   of view, it:
   -  Makes lines wrap at word boundaries. (controlled by var
      =truncate-lines= and =word-wrap=.)
   -  Makes up/down arrow keys move by a visual line. (controlled by
      the var =line-move-visual=.)
   -  Makes the =kill-line= command delete by a visual line, as
      opposed to a logical line.
   -  Turns off the display of little return arrow at the edge of
      window. (controlled by the var =fringe-indicator-alist=.)

   #+begin_src emacs-lisp :tangle yes
     (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
   #+end_src

   Sometimes (diff mode, or looking at big text tables) i don't want
   to have visual line mode. I will use =truncate-lines=

   #+begin_src emacs-lisp
     (bind-key "t" 'toggle-truncate-lines ctl-x-t-map)
   #+end_src

   Highlighting and coloring of the buffer
   #+begin_src emacs-lisp
     (use-package idle-highlight-mode :ensure t)
     (use-package rainbow-mode        :ensure t)
     (use-package rainbow-delimiters  :ensure t)
   #+end_src

   Highlighting current line
   #+begin_src emacs-lisp
     (use-package hl-line
       :commands hl-line-mode
       :bind ("C-x t h" . hl-line-mode)
       :config  (use-package hl-line+ :ensure t))
   #+end_src

   Highlighting on demand using `hi-lock` is already bound to =M-s h=
   prefix. We will move it to =M-h=  enhance it with few more things

   #+begin_src emacs-lisp
     (use-package hi-lock
       :config
       (use-package highlight-symbol
         :ensure t
         :config  (progn
                    (highlight-symbol-mode +1)
                    (bind-keys :prefix-map highlight-map
                               :prefix "M-h"
                               ("."    . highlight-symbol-at-point )
                               ("M-p"  . highlight-symbol-prev)
                               ("M-n"  . highlight-symbol-next)
                               ("l"    . highlight-lines-matching-regexp)
                               ("r"    . highlight-regexp)
                               ("p"    . highlight-phrase)
                               ("u"    . unhighlight-regexp)
                               ("C-g"  . highlight-symbol-remove-all)
                               ("M-r"  . highlight-symbol-query-replace)))))
   #+end_src

   Turn on/off showing trailing whitespace

   #+begin_src emacs-lisp
     (defun toggle-show-trailing-whitespace ()
       "Turns on/off showing of the trailing whitespaces in a current buffer"
       (interactive)
       (setq show-trailing-whitespace (not show-trailing-whitespace))
       (message (concat (if show-trailing-whitespace "Enabled" "Disabled") " showing trailing whitespace.") ))

     (defun turn-off-show-trailing-whitespace ()
       "Turns off trailing-whitespace mode - useful for REPLs"
       (interactive)
       (setq show-trailing-whitespace nil))
   #+end_src

   Add it to the toggle-map
   #+begin_src emacs-lisp
     (bind-key "SPC" 'toggle-show-trailing-whitespace ctl-x-t-map)
   #+end_src

   Toggles line numbers in the buffer
   #+begin_src emacs-lisp
     (bind-key "l"  'linum-mode ctl-x-t-map)
   #+end_src

** Completions / Snippets / Abbreviations

   Various types of speeding up typing - completions, snippets and
   abbreviations.

   Naturally =hippie-expand-try-functions-list= would be made local
   variable and adjusted for a mode in the mode settings
   #+begin_src emacs-lisp
      (bind-key "M-/"  'hippie-expand)
   #+end_src

   Due to inconveniences of the =auto-complete= package use =company=
   instead
   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :diminish company-mode
       :init (progn
                 (setq company-idle-delay 0.1
                       company-tooltip-limit 20
                       company-show-numbers t
                       company-selection-wrap-around t
                       company-minimum-prefix-length 1
                       company-tooltip-align-annotations t
                       company-echo-delay 0)
                 (use-package company-quickhelp
                   :defer t
                   :ensure t
                   :init (add-hook 'company-mode-hook #'company-quickhelp-mode)
                   :config (unbind-key "M-h" company-quickhelp-mode-map)
                   :pin melpa-stable))
       :config
       (progn
         ;; default `company-backends'
         (setq company-backends '(company-files
                                  company-capf
                                  company-yasnippet
                                  (company-dabbrev-code company-gtags company-etags company-keywords)
                                  company-dabbrev
                                  ))
         (defun ffy-add-company-backends (&rest backends)
           "Adds BACKENDS to the beginning of the buffer-local version of `company-backends' list"
           (set (make-local-variable 'company-backends)
                (append backends company-backends)))

         (global-company-mode 1)
         (bind-key "C-d" #'company-show-doc-buffer  company-active-map)
         (bind-key "M-?" #'company-complete)))
   #+end_src

   Snippets allow us to create code quickly
   #+begin_src emacs-lisp
     (use-package yasnippet
       :commands (yas-minor-mode yas-global-mode)
       :ensure t
       :init (setq yas-triggers-in-field t
                   yas-wrap-around-region t
                   yas-prompt-functions '(yas-ido-prompt yas-completing-prompt))
       :config  (progn
                  (add-to-list 'yas-snippet-dirs (concat *data-dir*  "snippets"))
                  ;; Prevent Yasnippet from loading default c++ snippets
                  (let ((file (concat yas-installed-snippets-dir "/c++-mode" "/.yas-skip")))
                    (when (not (file-exists-p file))
                      (write-region "" nil file)))
                  (yas-global-mode +1)
                  ;; add to hippie-expand
                  (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)))
   #+end_src

** Zapping
   Some of the zapping functions:

   - =zap-up-to-char= is a better alternative to regular zapping
     #+begin_src emacs-lisp
       (autoload 'zap-up-to-char "misc" "Kill up to, but not including ARGth occurrence of CHAR.
         \(fn arg char)" 'interactive)
     #+end_src

   - =zap-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-to-char-backwards (char)
           (interactive "cZap to char backwards: ")
           (zap-to-char -1 char))
     #+end_src

   - =zap-up-to-char-backwards=
     #+begin_src emacs-lisp
       (defun zap-up-to-char-backwards (char)
           (interactive "cZap up to char backwards: ")
           (zap-up-to-char -1 char))
     #+end_src

  Zapping key bindings
  #+begin_src emacs-lisp
    (bind-key "C-M-z"   'zap-to-char-backwards)
    (bind-key "M-Z"     'zap-up-to-char)
    (bind-key "C-M-S-z" 'zap-up-to-char-backwards)
  #+end_src

** Kill-rings
   Searching and browsing through the =kill-ring=
   #+begin_src emacs-lisp
     (use-package browse-kill-ring
       :ensure t
       :config  (progn
                  (browse-kill-ring-default-keybindings) ; advises M-y
                  (bind-key "C-x C-y" 'browse-kill-ring)))
     (use-package kill-ring-search
       :ensure t
       :config  (progn
                  (bind-key "C-M-y" 'kill-ring-search)))
   #+end_src

** Search/Navigation/Positioning
*** Search in a Buffer
    #+begin_src emacs-lisp
      (bind-key "C-S-r"  'search-backward)
      (bind-key "C-S-s"  'search-forward)
    #+end_src

    Occur =M-s o= and multi-occur =M-s O=. Same keys will call =occur=
    and =moccur= from =isearch-mode=
    
    #+begin_src emacs-lisp
      (use-package color-moccur
        :ensure t
        :commands isearch-moccur-all
        :bind ("M-s O" . moccur)
        :init
        (bind-key "M-s O" #'isearch-moccur-all isearch-mode-map))

    #+end_src

*** Search in Files
    #+begin_src emacs-lisp
      (use-package grep
        :defer t
        :config
        (progn
          (setq wgrep-enable-key "e")
          (bind-key "e" 'wgrep-change-to-wgrep-mode  grep-mode-map)))
    #+end_src

    In addition to =grep= we use =ag=

    #+begin_src emacs-lisp
      (use-package ag
        :load-path "site-lisp/ag-el"
        :config (setq ag-reuse-buffers t
                      ag-highlight-search t))
    #+end_src

*** Better BOL positioning

   First define better function =ffy-bol-or-back-to-indent= to
   position either to the beginning of the line or beginning of the
   indent and switch between this two positions if necessary

   #+name: ffy-bol-or-back-to-indent
   #+begin_src emacs-lisp
       (defun ffy-bol-or-back-to-indent ()
         "In addition to having two different mappings for
        (move-beginning-of-line ARG) and (back-to-indentation) we
        will have a function that goes to BOL if we are on the
        indent position and to the indent if we are at the BOL"
         (interactive)
         (if (bolp)
             (back-to-indentation)
           (move-beginning-of-line 1)))
   #+end_src

   Redefine =C-a= to =C-S-a= and =C-a to the =ffy-bol-or-back-to-indent=

   #+begin_src emacs-lisp
     (bind-key "C-S-a" (key-binding [(control ?a)]))
     (bind-key "C-a"  'ffy-bol-or-back-to-indent)
   #+end_src

*** Navigation Using Mark/Point Ring
    For better explanation see
    http://www.masteringemacs.org/articles/2010/12/22/fixing-mark-commands-transient-mark-mode/

    Pushes mark into a ring without activating a region

    #+name: ffy-position-to-ring
    #+begin_src emacs-lisp
      (defun ffy-position-to-ring ()
        "Pushes current position to the mark-ring"
        (interactive)
        (push-mark (point) t nil)
        (message "Position %s pushed to the ring" (point)))
    #+end_src

    Now =M-SPC= pushes point onto a mark ring and =C-u C-SPC= pops it
    off effectively positioning point

    #+begin_src emacs-lisp
      (bind-key  "M-SPC" 'ffy-position-to-ring)
    #+end_src

*** Ace Jumping

    Now we use =ace-jump-mode= and it makes =C-z SPC= and then
    character to jump to a word that starts from that character.
    =C-u C-z SPC= and a character to jump to that character and
    =C-u C-u C-z SPC= to jump to a line.

    #+begin_src emacs-lisp
      (use-package ace-jump-mode
        :ensure t
        :bind ("C-z SPC" . ace-jump-mode))
    #+end_src

*** Word navigation
Sometimes rather than moving to the end of the work via =forward-word=
I want to move to the beginning of the next word. 
#+begin_src emacs-lisp
  (defun next-word (&optional n)
    "Move point to the beginning of the word N words to the right"
    (interactive "^p")
    (forward-word (+ n 1))
    (backward-word))

  (bind-key "M-F" #'next-word)
#+end_src

** Folding and Hiding

   Visualizing HideShow mode folding. *IMPORTANT*: enabling =hideshowvis= in =nxml
   mode hangs up Emacs

   #+begin_src emacs-lisp
     (use-package hideshowvis
       :ensure t)
   #+end_src

   Useful folding commands that use =hideshow= or =TeX= folding.

   #+begin_src emacs-lisp
     (use-package fold-dwim
       :ensure t)
   #+end_src

   Good key-bindings i think could be in =Esc-Esc-...= keymap. I don't
   use =Esc= instead of =Meta= so it should work great. One can
   trigger =Esc= with =C-[=

   Assign keys for operations on folding and Hide/Show operations
   #+begin_src emacs-lisp
     (bind-keys :prefix-map esc-esc-map
                :prefix "<escape> <escape>"
                ;; save original keys
                ("<escape>" . keyboard-escape-quit)
                ;; now folding keys
                ("<up>" . fold-dwim-hide-all)
                ("<down>" . fold-dwim-show-all)
                ("<tab>" . fold-dwim-toggle)
                ("<left>" . hs-hide-block)
                ("<right>" . hs-show-block))
   #+end_src

** Marking
   Mark commands from =thing-cmds=
   #+begin_src emacs-lisp
     (use-package thing-cmds
       :ensure t
       :init (thgcmd-bind-keys))
   #+end_src

** Undo
   Undo/Redo functionality is done through =undo-tree=
   #+begin_src emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :config (global-undo-tree-mode))
   #+end_src

** Narrowing/Widening
   Enable useful disabled Narrow/Widen commands
   #+begin_src emacs-lisp
     (dolist (command '(narrow-to-region narrow-to-defun narrow-to-page widen set-goal-column))
       (put command 'disabled nil))
   #+end_src

** Thing At the Point
   Let's load up =thingatpt= and =thingatpt+= libraries and create
   additional functions that will change number at the point (if
   point is at the number):
   #+begin_src emacs-lisp
     (use-package thingatpt
       :defer t
       :config (progn
                 (use-package thingatpt+
                   :ensure t
                   :config (progn
                             ;; Rectifying the problem with some code (e.g.
                             ;; CIDER) that relies on standard behaviour
                             ;; of the tap functions
                             (tap-put-thing-at-point-props)
                             ;;(tap-redefine-std-fns) ;; This breaks CIDER
                             ;; This depends on the thingatpt and thingatpt+
                             (defun ffy-tap-number-change (&optional num)
                               "Changes the number at the point by `num' passed as a prefix argument. If no argument is passed then it uses 1, i.e. decrements and increments number at the point. If it is not a number at the point, then nothing happens."
                               (interactive "p")
                               (save-excursion
                                 (let ((n (tap-number-at-point-decimal))
                                       (bounds (tap-bounds-of-number-at-point)))
                                   (if (and n bounds)
                                       (progn
                                         (delete-region (car bounds) (cdr bounds))
                                         (insert (number-to-string (+ n (or num 1)))))))))

                             (defun ffy-tap-number-decrease (&optional num)
                               "Decreases number at the point by `num' or 1 if argument is not given"
                               (interactive "p")
                               (ffy-tap-number-change (- (or num 1))))

                             (defun ffy-tap-number-increase (&optional num)
                               "Increases number at the point by `num' or 1 if argument is not given"
                               (interactive "p")
                               (ffy-tap-number-change (or num 1)))

                             (bind-key "C--"  'ffy-tap-number-decrease)
                             (bind-key "C-+"  'ffy-tap-number-increase)))))
   #+end_src

   At the end we have keys =C--= and =C-+= bound to decreasing
   number at the point and increasing number at the point.

** Bookmarking

   #+begin_src emacs-lisp
     (use-package bm
       :ensure bm)

     (use-package bookmark
       :defer t
       :config
       (progn
         (use-package bookmark+
           :ensure t)))
   #+end_src

** Miscellaneous
   - =IMenu= defaults
     #+begin_src emacs-lisp
       (set-default 'imenu-auto-rescan t)
     #+end_src

   - use =C-\= to leave one space between words
     #+begin_src emacs-lisp
       (define-key global-map [(control ?\\)] 'just-one-space)
     #+end_src

   - there's default =M-^= =delete-indentation= that is an alias to
     =join-line=
     #+begin_src emacs-lisp
       (bind-key "j" 'join-line ctl-z-map)
       (bind-key "J" (lambda () "joins next line to this one"
                                      (interactive)
                                      (join-line 1)) ctl-z-map)
     #+end_src

* Version Control Systems
** Git
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :commands magit-status
       ;; Added global shortcut to run Magit
       :bind ("C-x g" . magit-status)
       :config (progn
                   ;(setq magit-auto-revert-mode nil)
                   (setq magit-last-seen-setup-instructions "1.4.0")))
   #+end_src

* Specific Modes
** Org Mode
*** Using Bleeding-Edge Version
   If decided to use =Org-mode= latest version then you could use it
   as a submodule of this repository. Before I had to create
   a repo on bitbucket.com so it could be successfly cloned on any
   machine (via https not git protocol).

   First of all go into =site-lisp/org-mode= and run =make autoloads=
   and =make info=. These commands will create all necessary files:
   =org-loaddefs.el= and info files.

   On Mac OS X there could be a problem, while running make in
   =site-lisp/org-mode= directory it will break with the dialog "This
   application will not run on your computer. Sorry!". This is a
   problem of launching script. Edit
   =/Application/Emacs.app/Contents/MacOS/Emacs= file - replace line

#+begin_src ruby
  exec versions[highest_compatible_version], *ARGV
#+end_src
 
With

#+begin_src ruby
  executable = versions[highest_compatible_version], *ARGV
  exec %("#{executable}")
#+end_src

   If that doesn't help just update Emacs.

   Now Emacs should load new org-mode.

*** Org-mode Setup 
**** Modules
    Modules to use with =org-mode=
    #+begin_src emacs-lisp
      (setq org-modules
            '(org-crypt
              org-docview
              org-gnus
              org-id
              org-info
              org-jsinfo
              org-protocol
              org-special-blocks
              org-w3m
              org-bookmark
              org-elisp-symbol
              org-panel))
    #+end_src

**** Completion
     Without it ido completion is not going to work for org-mode (see
     =org-read-property-value=). Alternative completion uses
     =org-completion-use-iswitchb=

     #+begin_src emacs-lisp
       (setq org-completion-use-ido t)
     #+end_src

     Make company completion work in Org-Mode (this function will be
     added to the =org-mode-hook=)

     #+name: add-pcomplete-to-capf
     #+begin_src emacs-lisp
       (defun add-pcomplete-to-capf ()
         (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
     #+end_src

**** Key Binding
     This is global binding. For binding to the =org-mode-map= see
     Loading org-mode or use =eval-after-load=
     #+begin_src emacs-lisp
       (bind-key "C-c b" 'org-iswitchb)
     #+end_src

     Consider binding following functions: =org-mark-ring-goto=,
      =org-store-link=, =org-agenda=,
      =outline-previous-visible-heading=,
      =outline-next-visible-heading=, =outline-up-heading=,
      =org-store-link=, =org-insert-link=

**** Appearance

     Customize TODO faces

     #+begin_src emacs-lisp
                                        ;(setq org-todo-keyword-faces
;      (quote (("TODO" :foreground "medium blue" :weight bold)
;              ("NOTE" :foreground "dark violet" :weight bold)
;              ("STARTED" :foreground "dark orange" :weight bold)
;              ("WAITING" :foreground "red" :weight bold)
;              ("DELEGATED" :foreground "red" :weight bold))))

     #+end_src

     Display images
     #+begin_src emacs-lisp
;;
;;  Setup iimage working with Org-mode
;;
;; (add-hook 'org-mode-hook 'turn-on-iimage-mode)

;; (defun org-toggle-iimage-in-org ()
;;   "display images in your org file"
;;   (interactive)
;;   (if (face-underline-p 'org-link)
;;       (set-face-underline-p 'org-link nil)
;;     (set-face-underline-p 'org-link t))
;;   (iimage-mode))

     #+end_src

     Do not re-organize windows when edit source blocks
     #+begin_src emacs-lisp
       (setq org-src-window-setup 'other-window)
     #+end_src

**** Miscelaneous
     Override not working function from org-mode
     #+name: org-read-property-value
     #+begin_src emacs-lisp
       (defun org-read-property-value (property)
         "Read PROPERTY value from user."
         (let* ((completion-ignore-case t)
                (allowed (org-property-get-allowed-values nil property 'table))
                (cur (org-entry-get nil property))
                (prompt (concat property " value"
                                (if (and cur (string-match "\\S-" cur))
                                    (concat " [" cur "]") "") ": "))
                (set-function (org-set-property-function property))
                (val (if allowed
                         (funcall set-function prompt allowed nil
                                  (not (get-text-property 0 'org-unrestricted
                                                          (caar allowed))))
                       (funcall set-function prompt
                                (mapcar 'list (org-property-values property))
                                nil nil "" nil cur))))
           (if (equal val "")
               cur
             val)))
     #+end_src

**** Loading =org-mode=

     #+begin_src emacs-lisp
       (use-package org
         :ensure t
         :defer t
         :init
         (progn
           (setq org-hide-leading-stars t
                 org-return-follows-link t
                 org-empty-line-terminates-plain-lists t
                 org-confirm-babel-evaluate nil
                 org-src-fontify-natively t)
           (ffy-add-hooks 'org-mode-hook
                          'turn-on-font-lock
                          'yas-minor-mode-on
                          'turn-on-auto-fill
                          'turn-on-flyspell
                          'hl-line-mode
                          'add-pcomplete-to-capf
                          'iimage-mode))
         :config
         (progn
           (org-babel-do-load-languages
            'org-babel-load-languages
            '((dot . t)
              (ditaa . t)
              (emacs-lisp . t)
              (python . t)))

           (unbind-key "M-h" org-mode-map))

         :bind (:map org-mode-map
                     ("C-c k" . org-cut-subtree)
                     ;;  Swap C-j and RET
                     ([remap org-return-indent] . org-return)
                     ([remap org-return] . org-return-indent)))

   #+end_src
**** Babel
     Do not run documentation fly checker on pieces of code
     #+begin_src emacs-lisp
       (add-hook 'org-src-mode-hook
                 (lambda ()
                   (if (eq major-mode 'emacs-lisp-mode)
                       (flycheck-disable-checker 'emacs-lisp-checkdoc))))
     #+end_src

**** Encryption
     Encryption of the entries

     #+begin_src emacs-lisp
       (use-package org-crypt
         :config (progn
                   (org-crypt-use-before-save-magic)
                   (setq org-tags-exclude-from-inheritance
                         (append '("crypt") org-tags-exclude-from-inheritance)))
         :bind (:map org-mode-map
                ("C-c e" . org-encrypt-entry)
                ("C-c d" . org-decrypt-entry)))
     #+end_src

*** Export
**** Using OX-REVEAL
#+begin_src emacs-lisp
  (use-package ox-reveal
    :config (progn
              ;; Overriding the org-reveal-src-block
              ;; to make it work with highlight.js
              (when nil
                (defun org-reveal-src-block (src-block contents info)
                  "Transcode a SRC-BLOCK element from Org to Reveal.
  CONTENTS holds the contents of the item.  INFO is a plist holding
  contextual information."
                  (if (org-export-read-attribute :attr_html src-block :textarea)
                      (org-html--textarea-block src-block)
                    (let ((lang (org-element-property :language src-block))
                          (caption (org-export-get-caption src-block))
                          (code (org-html-format-code src-block info))
                          (frag (org-export-read-attribute :attr_reveal src-block :frag))
                          (label (let ((lbl (org-element-property :name src-block)))
                                   (if (not lbl) ""
                                     (format " id=\"%s\""
                                             (org-export-solidify-link-text lbl))))))
                      (if (not lang)
                          (format "<pre %s%s>\n%s</pre>"
                                  (or (frag-class frag) " class=\"example\"")
                                  label
                                  code)
                        ;;        (format
                        ;;         "<div class=\"org-src-container\">\n%s%s\n</div>"
                        ;;         (if (not caption) ""
                        ;;           (format "<label class=\"org-src-name\">%s</label>"
                        ;;                   (org-export-data caption info)))
                        ;;          ;; Formatting code for highlight.js
                        ;; )
                        (format "\n<pre><code class=\"hljs %s\">%s</code></pre>"
                                ;; (or (frag-class frag)
                                ;;     (format " class=\"src src-%s\"" lang))
                                ;; label
                                lang
                                (car (org-export-unravel-code src-block)))))))

                )))
#+end_src

*** Orgtbl mode
    More about orgtbl
    http://dynamic-thinking.blogspot.com/2009/11/orgtbl-mode.html
     #+begin_src emacs-lisp
       (use-package orgtbl
         :disabled t
         :commands orgtbl-mode
         :config (progn
                   (defun orgtbl-to-gfm (table params)
             "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown.
       Usage Example:
         <!--- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
         <!--- END RECEIVE ORGTBL $1 -->
         <!---
         ,#+ORGTBL: SEND $1 orgtbl-to-gfm
          | $0 |
         -->
       For more details see https://gist.github.com/grafov/8244792 and https://gist.github.com/yryozo/5807243
       "
             (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                                          org-table-last-alignment ""))
                    (params2
                     (list
                      :splice t
                      :hline (concat alignment "|")
                      :lstart "| " :lend " |" :sep " | ")))
               (orgtbl-to-generic table (org-combine-plists params2 params))))))
     #+end_src

** Presentations
   We will use =epresent= mode for presentations right in the Emacs
   #+BEGIN_SRC emacs-lisp
     (use-package epresent
       :ensure t
       :defer t
       :init (progn
               ;; compatibility issues that are not covered in `org-compat.el'
               (when (< emacs-major-version 25)
                 (defalias 'outline-hide-body 'hide-body))))
   #+END_SRC

** Markdown
   #+begin_src emacs-lisp
     (use-package markdown-mode
       :defer t
       :ensure t
       :config  (progn
                  (defun set-markdown-mode-outline-regexp ()
                    "Add Markdown mode specifics.  Make outline-mode navigation work for underline headers as well"
                    (make-local-variable 'outline-regexp)
                    (setq outline-regexp "#+\\|^\\(.*\\)\n\\(===+\\|---+\\)$"))

                  (ffy-add-hooks 'markdown-mode-hook
                                 'set-markdown-mode-outline-regexp
                                 'outline-minor-mode)))
   #+end_src

** XML Based Editing
*** Pretty Print Functions
    #+name: xml-pretty-print
    #+begin_src emacs-lisp
      (defun xml-pretty-print (begin end)
        "Makes current buffer with XML markup look prettier"
        (save-excursion
          (nxml-mode)
          (goto-char begin)
          (while (search-forward-regexp "\>[ \\t]*\<" nil t)
            (backward-char) (insert "\n"))
          (indent-region begin end))
        (message "Ah, much better!"))
    #+end_src

    #+name: xml-pretty-print-region
    #+begin_src emacs-lisp
      (defun xml-pretty-print-region (begin end)
             "Pretty format XML markup in region. You need to have nxml-mode
           http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
           this.  The function inserts linebreaks to separate tags that have
           nothing but whitespace between them.  It then indents the markup
           by using nxml's indentation rules."
             (interactive "r")
             (xml-pretty-print begin end))
    #+end_src

    #+name: xml-pretty-print-buffer
    #+begin_src emacs-lisp
      (defun xml-pretty-print-buffer ()
             "Formats whole buffer containing XML"
             (interactive)
             (xml-pretty-print-region (point-min) (point-max)))
    #+end_src

*** XML Mode Setup

    #+name: ffy-customize-nxml-mode
    #+begin_src emacs-lisp
      (defun ffy-customize-nxml-mode ()
        "This function sets some variables and calls some functions that setup nXML mode."
        ;; load hide show modes
        (local-set-key "\C-c/" 'nxml-finish-element)
        (local-set-key [return] 'newline-and-indent)
        ;;(auto-fill-mode)
        (rng-validate-mode)
        (unify-8859-on-decoding-mode)
        (setq ispell-skip-html t)
        (hs-minor-mode 1)
        ;; controversial
        (make-variable-buffer-local 'ido-use-filename-at-point)
        (setq ido-use-filename-at-point nil))
    #+end_src

    #+begin_src emacs-lisp
      (use-package nxml-mode
        :defer t
        :config
        (setq
         ;; Treat elements and contents like S-expressions! Oh, the magic.
         ;; (if you know S-expression movement commands, it's great)
         nxml-sexp-element-flag t
         ;; Whenever you type </ it will fill out the rest.
         nxml-slash-auto-complete-flag t
         ;; Causes files with extensions .xml .xsl .rng .xhtml .html and .tal
         ;; to invoke nxml-mode.
         auto-mode-alist
         (cons '("\\.\\(xml\\|xsl\\|rng\\|tal\\|xsd\\|sch\\|xslt\\|svg\\|rss\\)\\'" . nxml-mode)
               (remove-if (lambda (x) (eq (cdr x) 'html-mode)) auto-mode-alist))
         ;; another way to recognize XML files
         magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))

        (add-hook 'nxml-mode-hook 'ffy-customize-nxml-mode)
        (add-to-list 'hs-special-modes-alist
                     '(nxml-mode
                       "\\|<[^/>]&>\\|<[^/][^>]*[^/]>"
                       ""
                       nil)))
    #+end_src

** JSON
   Editing JSON files using =json-mode=
   #+begin_src emacs-lisp
     (defun json-mode-insert-semicolon ()
       "Smart insertion of `:` while point is on a key. Point goes to the : or inserts new one after the key. This is helpful if keys are quoted strings."
       (interactive)
       (insert ":"))

     (defun json-mode-insert-open-brace ()
       "Smart insertion of `{'"
       (interactive)
       (insert "{"))

     (use-package json-mode
       :ensure t
       :commands json-mode
       ;; :bind (:map json-mode-map
       ;;             (":" . json-mode-insert-semicolon)
       ;;             ("{" . json-mode-insert-open-brace)
       ;;             )
       )
   #+end_src

** TeX
   TeX editing and preview. We are using AucTeX. You can see their
   web-site for instructions.

   For installing AucTeX on Windows:
   - Download and install the pre-compiled bundle of [[http://www.gnu.org/software/auctex/download-for-windows.html][AucTeX]].
   - Unpack that archive into an Emacs directory (even though it says
     do not use pre-built thing with anything other than Emacs 24.2,
     it works with Emacs 24.3). Before you do that backup your
     ~Emacs/info/dir~ file, then compare the two (new dir and backup
     dir) and copy whatever is missing from the backed up one to the
     new one.


   Links:
   - http://cseweb.ucsd.edu/~s1pan/install_auctex.html
   - http://www.gnu.org/software/auctex/download-for-windows.html


   Another option is to install it using ELPA

   #+begin_src elisp
     (use-package auctex
       :ensure t
       :init (progn
               (load "auctex-pkg.el" nil t t)
               (load "preview.el" nil t t)))
   #+end_src


   For XeTeX use command ~M-x TeX-engine-set~


   Good viewer for PDF (and other files) on Windows is
   [[http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html][Sumatra PDF]].

   Setting up Tex previewer
   http://tex.stackexchange.com/questions/119645/emacs-auctex-view-command

*** ConTeXt specifics
    For the Context we assume that version MKiV is used. Then
    everything is run via =mtxrun= or =context= commands.

** Shell
   Setup for the shell window in the Emacs
   #+begin_src emacs-lisp :tangle yes
     (add-hook 'shell-mode-hook #'turn-off-show-trailing-whitespace)
   #+end_src

** Modes for specific files
   For getting the text content of the word documents:

   #+begin_src emacs-lisp
     (when (executable-find "docx2txt")
       (add-to-list 'auto-mode-alist '("\\.docx\\'" . docx2txt))

       (defun docx2txt ()
         "Run docx2txt on the entire buffer."
         (shell-command-on-region (point-min) (point-max) "docx2txt" t t)))
   #+end_src

   Mercurial settings are edited using =conf-mod=
   #+begin_src emacs-lisp
     (dolist (pattern '("\\.hgrc\\'"
                        "\\.hg/hgrc\\'"
                        "Mercurial\\.ini\\'"))
       (add-to-list 'auto-mode-alist (cons pattern 'conf-mode)))
   #+end_src

   NGINX configuration files
   #+begin_src emacs-lisp
     (use-package nginx-mode :ensure t :commands nginx-mode)
   #+end_src

   Docker configuration files
   #+begin_src emacs-lisp
     (use-package dockerfile-mode :ensure t :commands dockerfile-mode)
   #+end_src



* Programming
** General Programming
*** Programming Modes Hook

    All programming modes will benefit from following functions:

    - =local-column-number-mode=
      #+begin_src emacs-lisp
        (defun local-column-number-mode ()
          (make-local-variable 'column-number-mode)
          (column-number-mode t))

        (add-hook 'prog-mode-hook #'local-column-number-mode)
      #+end_src
    - =local-comment-auto-fill=
      #+begin_src emacs-lisp
        (defun local-comment-auto-fill ()
          (set (make-local-variable 'comment-auto-fill-only-comments) t)
          (auto-fill-mode t))

        (add-hook 'prog-mode-hook #'local-comment-auto-fill)
      #+end_src
    - =turn-on-hl-line-mode=
      #+begin_src emacs-lisp
        (defun turn-on-hl-line-mode ()
          (if window-system (hl-line-mode t)))

        (add-hook 'prog-mode-hook #'turn-on-hl-line-mode)
      #+end_src
    - =pretty-greek=  replaces words like
      _lambda_ and _alpha_ with Greek symbols
      #+begin_src emacs-lisp
        (defun pretty-greek ()
          (let ((greek '("alpha" "beta" "gamma" "delta" "epsilon" "zeta" "eta" "theta" "iota" "kappa" "lambda" "mu" "nu" "xi" "omicron" "pi" "rho" "sigma_final" "sigma" "tau" "upsilon" "phi" "chi" "psi" "omega")))
            (loop for word in greek for code = 97 then (+ 1 code) do
                  (let ((greek-char (make-char 'greek-iso8859-7 code)))
                    (font-lock-add-keywords
                     nil
                     `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[a-zA-Z]")
                        (0
                         (progn
                           (decompose-region (match-beginning 2)
                                             (match-end 2))
                           nil)))))
                    (font-lock-add-keywords
                     nil
                     `((,(concatenate 'string "\\(^\\|[^a-zA-Z0-9]\\)\\(" word "\\)[^a-zA-Z]")
                        (0
                         (progn
                           (compose-region (match-beginning 2)
                                           (match-end 2) ,greek-char)
                           nil)))))))))

        (add-hook 'prog-mode-hook #'pretty-greek)
      #+end_src
    - =turn-on-fic-mode= highlights FIXME and XXX in the comments
      #+begin_src emacs-lisp
        (autoload 'turn-on-fic-mode "fic-mode")
        (add-hook 'prog-mode-hook #'turn-on-fic-mode)
      #+end_src
    - =turn-on-flyspell-prog-mode=
      #+begin_src emacs-lisp
        (defun turn-on-flyspell-prog-mode ()
          (when (and (boundp 'ispell-program-name)
                     (executable-find ispell-program-name))
            (flyspell-prog-mode)))

        (add-hook 'prog-mode-hook #'turn-on-flyspell-prog-mode)
      #+end_src
    - =flycheck= checking the code on the fly
      #+begin_src emacs-lisp
        (use-package flycheck
          :ensure t
          :pin melpa-stable
          :config (add-hook 'prog-mode-hook #'flycheck-mode))
      #+end_src
    - =turn-on-electric-mode= inserts pair symbol
      #+begin_src emacs-lisp
        (defun turn-on-electric-mode ()
          (electric-pair-mode +1))
      #+end_src

*** Global tags
    Make sure GNU Global is installed. Mac has port for that and binaries
    for Windows are [[http://adoxa.altervista.org/global/][here]]
    #+begin_src emacs-lisp
      (use-package ggtags
        :ensure t
        :init (progn
                (defun turn-on-ggtags-mode ()
                  (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                    (ggtags-mode 1)))
      
                (add-hook 'c-mode-common-hook 'turn-on-ggtags-mode)))
    #+end_src

** Paredit
   Nice mode for dealing with all those parentheses in lisp modes
   #+begin_src emacs-lisp
     (use-package paredit
       :ensure t
       :diminish paredit-mode
       :config (progn
                 (defun ffy-paredit-forward-delete ()
                   "Forces deleting a character in ParEdit mode"
                   (paredit-forward-delete +1))

                 (bind-key "C-S-d" 'ffy-paredit-forward-delete  paredit-mode-map)

                 (defun ffy-init-lisp-minibuffer-enable-paredit-mode ()
                   "Enable function `paredit-mode' during `eval-expression'. Adding `paredit-mode' for an `eval-expression' in minibuffer. RET  works as an exit minibuffer with evaluation."
                   (if (eq this-command 'eval-expression)
                       (when (fboundp 'paredit-mode)
                         (paredit-mode +1))))
                 ;; this will enable paredit in mini-buffer
                 (add-hook 'minibuffer-setup-hook 'ffy-init-lisp-minibuffer-enable-paredit-mode)

                 ;; we use M-s for searching stuff
                 (unbind-key "M-s" paredit-mode-map)
                 ;; bind splice onto M-k since we shouldn't use it in lisp
                 ;; mode anyway
                 (bind-key "M-k" #'paredit-splice-sexp paredit-mode-map)))
   #+end_src

** Emacs Lisp
   Modes that deal with Emacs-Lisp
   #+begin_src emacs-lisp
     (defconst *emacs-lisp-modes* '(emacs-lisp-mode lisp-mode ielm-mode))
   #+end_src

   Use ~eldoc-mode~ for buffer and mini-buffer

   #+begin_src emacs-lisp
     (use-package eldoc
       :defer t
       :diminish eldoc-mode
       :commands eldoc-mode
       :init (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode))
   #+end_src


   SLIME-like navigation in emacs
   #+begin_src emacs-lisp
     (use-package elisp-slime-nav
       :ensure t
       :diminish elisp-slime-nav-mode
       :init (progn
               (defun turn-on-elisp-slime-nav-mode ()
                 "Turns SLIME style navigation on in Emacs-lisp."
                 (elisp-slime-nav-mode 1))))
   #+end_src

   Add Emacs-Lisp specific completions and navigation mode to the
   setup of Emacs-Lisp modes

   #+begin_src emacs-lisp
     (defun ffy-emacs-lisp-modes-completions-setup ()
       "Emacs-lisp related completions."
       (progn
         (make-local-variable 'hippie-expand-try-functions-list)
         (dolist (func '(try-complete-lisp-symbol try-complete-lisp-symbol-partially))
           (add-to-list 'hippie-expand-try-functions-list
                        func
                        'to-the-end))))
   #+end_src

*** Highlighting

    Enrich highlighting in Emacs-Lisp

    #+begin_src emacs-lisp
      (use-package highlight-cl
        :ensure t
        :config (progn
                  (defun turn-on-highlight-cl ()
                    (when (fboundp 'highlight-cl-add-font-lock-keywords)
                      (highlight-cl-add-font-lock-keywords)))))
    #+end_src

    Parentheses
    #+begin_src emacs-lisp
      (use-package highlight-parentheses
        :ensure t
        :commands highlight-parentheses-mode)
    #+end_src

    add highlighting quoted symbols
    #+begin_src emacs-lisp
      (font-lock-add-keywords 'emacs-lisp-mode '(("'\\(\\sw\\|\\s_\\)+" . font-lock-constant-face)))
    #+end_src

*** IELM - Emacs Lisp Interpreter
    Interpreter of Emacs-Lisp running in Emacs. Very helpful if we
    want run some command or change settings or instrument
    major/minor mode of the buffer we currently working on

    We want to indent if we press =RET= while inside of the
    S-expression and execute it if we are at the end.

    #+begin_src emacs-lisp
      (defun ffy-ielm-return ()
        "Like `ielm-return' but more intellectual when it comes to deciding when just
      send `paredit-newline' instead.
      Implementation shamelessly stolen from: https://github.com/jwiegley/dot-emacs/blob/master/init.el"
        (interactive)
        (let ((end-of-sexp (save-excursion
                                 (goto-char (point-max))
                                 (skip-chars-backward " \t\n\r")
                                 (point))))
              (if (>= (point) end-of-sexp)
                  (progn
                    (goto-char (point-max))
                    (skip-chars-backward " \t\n\r")
                    (delete-region (point) (point-max))
                    (call-interactively #'ielm-return))
                (call-interactively #'paredit-newline))))
    #+end_src

    Hook =ffy-ielm-return= onto the =RET= key

    #+begin_src emacs-lisp
      (defun ffy-setup-ielm ()
        "Sets some IELM defaults and keys."
        (interactive)
        (progn
          (local-set-key [return] 'ffy-ielm-return)))
    #+end_src

    And add it to the  IELM setup hook
    #+begin_src emacs-lisp
      (add-hook 'ielm-mode-hook 'ffy-setup-ielm)
    #+end_src


    We want to start new IELM session with the current buffer only if
    we don't have IELM running. If we do, we just want to switch to
    IELM instead

    #+begin_src emacs-lisp
      (defun ffy-ielm ()
        "Starts IELM or switches to existing one in the new window and sets working buffer of IELM to the current buffer."
        (interactive)
        (let ((buf (current-buffer)))
          (if (get-buffer "*ielm*")
              (switch-to-buffer-other-window "*ielm*")
            (progn
              (split-window-sensibly (selected-window))
              (other-window 1)
              (ielm)))
          (ielm-change-working-buffer buf)))
    #+end_src

    Press =C-c M-:= to start IELM with current buffer
    #+begin_src emacs-lisp
      (bind-key "C-c M-:" 'ffy-ielm)
    #+end_src

*** Finally add the hooks
    #+begin_src emacs-lisp
      (dolist (mode *emacs-lisp-modes*)
        (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
          (ffy-add-hooks  mode-hook
                          'ffy-emacs-lisp-modes-completions-setup
                          'enable-paredit-mode
                          'turn-on-elisp-slime-nav-mode
                          'turn-on-eldoc-mode
                          'rainbow-delimiters-mode-enable
                          'highlight-parentheses-mode
                          'turn-on-highlight-cl)))
    #+end_src

*** Key Binding

    #+begin_src emacs-lisp
      (bind-keys :map lisp-mode-shared-map
                 ("<M-return>" . reindent-then-newline-and-indent)
                 ("C-x x" . eval-print-last-sexp)
                 ("<C-M-backspace>" . backward-kill-sexp))
    #+end_src

** Clojure
   #+begin_src emacs-lisp
     (use-package clojure-mode
       :ensure t
       :init (progn
               (ffy-add-hooks 'clojure-mode-hook
                              'ffy-find-file-in-clojure-project
                              'subword-mode
                              'enable-paredit-mode
                              'turn-on-eldoc-mode
                              'rainbow-delimiters-mode-enable)))
     (use-package elein
       :ensure t)
   #+end_src

   #+begin_src emacs-lisp
     (defun ffy-find-file-in-clojure-project ()
       "For Clojure we are also looking for project.clj file in the project root"
       (progn
         (require 'find-file-in-project)
         (when (boundp 'ffip-project-file)
           (set (make-local-variable 'ffip-project-file)
                (if (listp 'ffip-project-file)
                    (cons "project.clj" ffip-project-file)
                  (list "project.clj" ffip-project-file))))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package cider
       :ensure t
       :pin melpa-stable
       :init (progn
                (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
                (ffy-add-hooks 'cider-repl-mode-hook
                               'subword-mode
                               'turn-on-eldoc-mode
                               'enable-paredit-mode
                               'turn-off-show-trailing-whitespace)
               (ffy-add-company-backends 'cider-complete-at-point)
               (bind-key "<M-return>" 'reindent-then-newline-and-indent  lisp-mode-shared-map)
               (bind-key "C-x x" 'eval-print-last-sexp  lisp-mode-shared-map)))
   #+end_src

** Ruby/Rails setup
   Loading  Ruby and Rails relate ELPA packages
   #+begin_src emacs-lisp
     (use-package ruby-mode
       :ensure t
       :init (progn
               (use-package rinari
                 :ensure t
                 :config
                 (global-rinari-mode 1))
               (use-package rspec-mode :ensure t)
               (use-package ruby-compilation :ensure t)
               (use-package ruby-electric :ensure t)
               (use-package ruby-end
                 :ensure t
                 :config (progn
                           (defalias 'ruby-insert-end 'ruby-end-insert-end)))
               (use-package rvm :ensure t)
               (use-package yari :ensure t)

               (defun ffy-insert-ruby-string-interpolation ()
                 "In a double quoted string, interpolation is inserted on #."
                 (interactive)
                 (insert "#")
                 (when (and
                        (looking-back "\".*")
                        (looking-at ".*\""))
                   (insert "{}")
                   (backward-char 1)))
               )
       :config (progn
                 (bind-key "<return>" 'reindent-then-newline-and-indent ruby-mode-map)
                 (bind-key "#" 'ffy-insert-ruby-string-interpolation  ruby-mode-map)
                 (bind-key "C-h r" 'yari  ruby-mode-map)
                 (ffy-add-hooks 'ruby-mode-hook
                                'subword-mode
                                'ruby-electric-mode
                                'local-column-number-mode
                                'local-comment-auto-fill
                                'turn-on-hl-line-mode
                                'turn-on-fic-mode
                                'turn-on-flyspell-prog-mode
                                'inf-ruby-minor-mode))
       :mode (("\\.rb$" . ruby-mode)
              ("\\.rake$" . ruby-mode)
              ("\\.gemspec$" . ruby-mode)
              ("\\.ru$" . ruby-mode)
              ("Rakefile$" . ruby-mode)
              ("Gemfile$" . ruby-mode)
              ("Capfile$" . ruby-mode)
              ("Guardfile$" . ruby-mode)))
   #+end_src

** YAML
   This is closely related to Ruby/Rails
   #+begin_src emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode (("\\.ya?ml$" . yaml-mode)))
   #+end_src

** HAML/SCSS/SASS/Less
   Closely related to Ruby/Rails development

   #+begin_src emacs-lisp
     (use-package haml-mode
       :ensure t
       :commands haml-mode
       :mode ("\\.haml$" . haml-mode))

     ;;; custom line opening
     (defun ffy-open-line-indented (n)
       "like `open-line' but keeps indentation"
       (interactive "*p")
       (let* ((loc (point-marker)))
         (newline-and-indent)
         (goto-char loc)))

     (use-package scss-mode
       :ensure t
       :defer t
       :commands scss-mode
       :mode ("\\.scss$" . scss-mode)
       :init (progn
               ;; my own customizations
               (defun ffy-customize-sass-scss-mode ()
                 (interactive)
                 ;; first of all <ret> sets newline and indent as C-j
                 (local-set-key [return] 'newline-and-indent)
                 (local-set-key [(control return)] 'ffy-open-line-indented))
               (use-package sass-mode
                 :ensure t
                 :defer t
                 :commands sass-mode
                 :mode ("\\.sass$" . sass-mode)
                 :config (progn
                           (ffy-add-hooks 'sass-mode-hook
                                          'local-column-number-mode
                                          'local-comment-auto-fill
                                          'turn-on-hl-line-mode
                                          'turn-on-fic-mode
                                          'turn-on-flyspell-prog-mode
                                          'ffy-customize-sass-scss-mode)))

               (ffy-add-hooks 'scss-mode-hook
                              'local-column-number-mode
                              'local-comment-auto-fill
                              'turn-on-hl-line-mode
                              'turn-on-fic-mode
                              'turn-on-flyspell-prog-mode
                              'ffy-customize-sass-scss-mode)))

     ;;; add Auto-Complete HAML SCSS and SASS modes
     ;(dolist (mode '(haml-mode sass-mode scss-mode))
     ;  (add-to-list 'ac-modes mode))
   #+end_src

   adding [[http://lesscss.org/][LESS]] files editing

   #+begin_src emacs-lisp
     (use-package less-css-mode
       :ensure t
       :defer t)
   #+end_src

** JavaScript
*** Additional Reading

    Good link about setting up JavaScript:
    - [[http://blog.deadpansincerity.com/2011/05/setting-up-emacs-as-a-javascript-editing-environment-for-fun-and-profit/][Setup Emacs as a JavaScript IDE For Fun and Profit]]
*** JavaScript
    #+begin_src emacs-lisp
      (use-package js2-mode :defer t :ensure t
        :mode (("\\.js\\'" . js2-mode)
               ("\\.jsx\\'" . js2-jsx-mode))
        :init
        (ffy-add-hooks 'js2-mode-hook
                       'js2-imenu-extras-mode
                       'imenu-add-menubar-index)
        :config
        (setq js2-mode-show-parse-errors nil  ; disable parser errors
              js2-mode-show-strict-warnings nil ; disable strict warnings.
              js2-highlight-level 3   ; highlight ECMA built-ins
              ))
    #+end_src

*** Rhino
**** Setup Rhino
       - On Windows:
         + Download rhino1_7R4.zip from Mozilla page.
         + Unpack it and copy js.jar to =%JRE_HOME%\lib\ext=

       - On Mac OS X:
         + Download rhino and unzip it
         + Make a the library directory if it doesn't exist:
           #+begin_example
            mkdir -p ~/Library/Java/Extensions
           #+end_example

         + Copy the jar to the extensions directory:
           #+begin_example
            cp ~/Downloads/rhino1_7R2/js.jar ~/Library/Java/Extensions/
           #+end_example

**** Running Rhino

     Run the following command:
     #+begin_example
       java org.mozilla.javascript.tools.shell.Main
     #+end_example

*** Node.js
    Make sure =node.js= and =npm= are installed.
    Install =jshint=, =jslint= and =tern= _globally_ using =npm=

    #+BEGIN_SRC shell
      npm install jshint jslint tern -g
    #+END_SRC

    Configure =tern.js=

    #+begin_src emacs-lisp
      (use-package tern :defer t :ensure t
        :init
        (add-hook 'js2-mode-hook #'tern-mode))
    #+end_src

    Auto-completion using =company-tern= and =company=

    #+begin_src emacs-lisp
      (use-package company-tern :defer t  :ensure t
        :init (progn
                (defun ffy-js2-mode-company-hook ()
                  (ffy-add-company-backends 'company-tern 'company-semantic))
                  (add-hook 'js2-mode-hook #'ffy-js2-mode-company-hook)))
    #+end_src

*** Documentation

    Writing JSDoc comments
    #+begin_src emacs-lisp
      (use-package js-doc  :ensure t :defer t
        :init
        (defun ffy-js-doc-insert-tag ()
          "Inserts @ or calls js-doc insert tag if in JsDoc comment"
          (interactive)
          (if (js-doc-in-document-p (point))
            (js-doc-insert-tag)
          (insert "@")))
        :bind (:map js2-mode-map
                    ("C-c C-d d" . js-doc-insert-file-doc)
                    ("C-c C-d f" . js-doc-insert-file-doc)
                    ("C-c C-d h" . js-doc-describe-tag)
                    ("@" . ffy-js-doc-insert-tag )))
    #+end_src


*** TODO Consider More Functionality
**** Swank.JS
     using  =swank.js=


      Add Swank-js from http://www.idryman.org/blog/2013/03/23/installing-swank-dot-js/
      Install Swank.js by
      #+begin_example
         npm install -g swank-js
      #+end_example

      Test by running

      #+begin_example
         swank-js
      #+end_example

      And directing browser to http://localhost:8009/swank-js/test.html

**** Js-Comint

     #+begin_src emacs-lisp tangle:no
     (use-package js-comint
     :disabled t
     :ensure t
     :config (setq inferior-js-program-command "node --interactive"))
     #+end_src

**** Remote debugging in a browser
   Good package for remote debugging in the browser is =jss=. Read
   more at https://github.com/segv/jss
   #+begin_src emacs-lisp tangle:no
     (use-package jss
       :disabled t
       :ensure t
       :defer t)
   #+end_src

** Octave Mode
   #+begin_src emacs-lisp
     (setq auto-mode-alist
           (cons '("\\.m$" . octave-mode) auto-mode-alist))
     (add-hook 'octave-mode-hook (lambda ()
                                   (auto-fill-mode 1)))
   #+end_src

** Haskell Mode
   The easiest way to start with Haskell is to install Haskell
   Platform. The caveat here is that GHC is a little bit old.

   #+begin_src emacs-lisp
     (use-package haskell-mode
       :ensure t
       :init (progn
               (ffy-add-hooks  'haskell-mode-hook
                      'local-column-number-mode
                      'local-comment-auto-fill
                      'turn-on-hl-line-mode
                      'pretty-greek
                      'turn-on-fic-mode
                      'turn-on-flyspell-prog-mode
                       ;; turn-on-flymake

                      'turn-on-haskell-doc-mode
                       ;; turn-on-haskell-indent

                     'turn-on-haskell-indentation
                     'interactive-haskell-mode)))
   #+end_src

   To provide navigation to definitions we need to install =hasktags=
   via =cabal install hasktags= into a global.

   #+begin_src emacs-lisp
     (when (executable-find "hasktags")
       (custom-set-variables
        '(haskell-tags-on-save t)))
   #+end_src

   To provide addition functionality we install =ghc-mod= package
   using cabal, if it is not installed yet =cabal install ghc-mod=.

   If you use GHC version 7.8 and later, then chances are you have
   some of the functionality already there (such as =:complete=)

   For auto-completion there's a package =company-ghc=
   (https://github.com/iquiw/company-ghc). It will also install =ghc=
   package as a dependency

   #+begin_src emacs-lisp
     (use-package company-ghc
       :ensure t
       :init (progn
               (ffy-add-company-backends 'company-ghc)
               (add-hook 'haskell-mode-hook 'ghc-init)))
   #+end_src

   More details on =ghc-mod= and emacs =ghc= package are available at
   http://www.mew.org/~kazu/proj/ghc-mod/en/

   Interesting configurations to look at:
   - https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el
   - https://github.com/serras/emacs-config-2/blob/master/haskell.el

   Configuration tutorial at
   https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

   
   Keys:
   - =M-RET= add import
   - =M-t= add signature to the function missing it.

   
*** GHCi

    Interpreter in haskell is available at =C-c C-l= but only in
    Cabal projects.

    Install =hoogle= package to search for the Haskell code and
    documentation in the libraries.

    Installing hoogle on Mac OS X with GHC 7.6.3 (the one from
    Haskell Platform ) will most likely fail due to the bug in
    compiler. It manifests itself as an error while installing
    =conduit= package (error itself described here :
    https://github.com/snoyberg/conduit/issues/147 ). To fix it one
    needs to put a wrapper for llvm preprocessor. Details are here
http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9.
    However binary wrapper is not available anymore. To fix it using
    bash script go here: https://www.haskell.org/platform/mac.html
    In short, it will patch haskell platfor (settings file) to make
    it work with clang.

    After installing =hoogle=, add call to hoogle to ghci (see
    http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration).

    If command line works then it will also work =haskell-mode=,
    check variable =haskell-hoogle-command=

** Python
   On Mac to use Python one should use MacPorts then one could see
   available pythons via =port select --list python=. To activate
   python use =sudo port select --set python python27=. Install =pip=
   using MacPorts, =sudo port install py-pip=. If installation fails
   run =clean= command and repeat. It should install =pip= for
   appropriate version of Python (the one that has been activated).

   When =pip= is installed using =get-pip.py= script it fails to
   install some packages, probably because of missing deps.

   #+begin_src emacs-lisp
     (use-package python
       :config
       (let ((ipython (executable-find "ipython")))
         (if ipython
             (setq python-shell-interpreter ipython)
           (warn "No IPython Found"))))
   #+end_src

   Completion and navigation is done using ~anaconda~. Install it
   using ~pip install anaconda_mode~

   #+begin_src emacs-lisp
     (use-package anaconda-mode
       :defer t
       :ensure t
       :init (progn
               (add-hook 'python-mode-hook #'anaconda-mode)
               (add-hook 'python-mode-hook #'anaconda-eldoc-mode))
       :config (progn
                 (bind-key "C-M-i" nil anaconda-mode-map)
                 (bind-key "M-?" nil anaconda-mode-map)
                 (bind-key "C-c C-d" 'anaconda-mode-show-doc anaconda-mode-map)))

     (use-package company-anaconda
       :defer t
       :ensure t
       :init (progn
               (add-hook 'python-mode-hook (lambda () (ffy-add-company-backends 'company-anaconda)))))
   #+end_src

** C/C++
   Writing C/C++ programs.
   Good source of information [[http://tuhdo.github.io/c-ide.html]]

   #+begin_src emacs-lisp
     (use-package cc-mode
       :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
              ("\\.m\\'"                   . c-mode)
              ("\\.mm\\'"                  . c++-mode))
       )
   #+end_src

   Using =company-c-headers=. By default, it adds only C headers.
   Adding C++ paths needs to be manual and system dependent. In its
   easiest form figuring out what are the paths is as easy as =g++
   -v=. More information about preprocessors paths could be found at
   https://gcc.gnu.org/ml/gcc-help/2007-09/msg00206.html


   Location of header files for C/C++. =ffy-c-headers-locations= may
   be defined in the system specific file. If it is not, then we use
   empty list.

   On Mac OS X after 10.8 =g++= is actually a =clang=.
   Another way is =cpp -Wp -v=

   Finding paths with Clang =clang -E -x c++ -v test.c=

   #+begin_src emacs-lisp
     (use-package company-c-headers
       :defer t
       :ensure t
       :config (progn
                 (dolist (dir (if (boundp 'ffy-c-headers-locations)
                                  ffy-c-headers-locations
                                ()))
                   (add-to-list 'company-c-headers-path-system dir))))
   #+end_src

   Configuring Clang and Mingw on Windows
   https://yongweiwu.wordpress.com/2014/12/24/installing-clang-3-5-for-windows/

   Adding =c-eldoc= (not from MELPA but from my repo)

   #+begin_src emacs-lisp
     (use-package c-eldoc
       :defer t
       :ensure t
       :config (setq c-eldoc-includes
                     (mapconcat #'identity
                                ;; on Windows `pkg-config` .... leads to an
                                ;; error
                                (cons ;c-eldoc-includes
                                      "-I. -I.."
                                      (mapcar (apply-partially #'concat "-I")
                                              ffy-c-headers-locations))
                                " ")
                     c-eldoc-cpp-command "cpp"))
   #+end_src

   =cc-mode= has a bug that makes =c-mode-hook= run twice
   (http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16759). This is some
   defensive programming.

   #+begin_src emacs-lisp
     (defun ffy-c-mode-hook ()
       "This is settings for the C/C++ mode"
       (when (memq major-mode '(c-mode c++-mode))
         (electric-pair-mode +1)
         (electric-indent-local-mode +1)
         (c-toggle-hungry-state +1)
         (c-set-style "gnu")
         (setq c-basic-offset 4)
         (set (make-local-variable 'compile-command)
              (let ((f (file-name-nondirectory (buffer-file-name))))
                (case major-mode
                  ('c-mode (format "gcc -g -O2 -std=gnu99 -static -lm %s" f))
                  ('c++-mode (format "g++ -g -O2 -static -std=gnu++11 %s" f))
                  (t compile-command))))
         (ffy-add-company-backends 'company-c-headers 'company-semantic 'company-clang 'company-xcode)))
     ;;; due to a bug http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16759 we
     ;;; add it to a c-mode-common-hook
     (add-hook 'c-mode-common-hook #'ffy-c-mode-hook)
   #+end_src

** Groovy
   #+begin_src emacs-lisp
     (use-package groovy-mode
       :ensure t
       :commands groovy-mode
       :mode (("\\.groovy\\'" . groovy-mode))
       :config (progn
                 (defun unstringify ()
                   (interactive)
                   (save-excursion
                     (beginning-of-buffer)
                     (while (re-search-forward "\\\\r\\\\n" nil t)
                       (replace-match "
     "))
                     (beginning-of-buffer)
                     (while (re-search-forward "\\\\/" nil t)
                       (replace-match "/"))
                     (beginning-of-buffer)
                     (while (re-search-forward "\\\\\""  nil t)
                       (replace-match "\""))
                     (beginning-of-buffer)
                     (zap-to-char 1 ?\")
                     (end-of-buffer)
                     (zap-to-char-backwards ?\")))

                 (defun stringify ()
                   (interactive)
                   (save-excursion
                     (beginning-of-buffer)
                     (while (re-search-forward "
     " nil t)
                       (replace-match "\\\\r\\\\n"))
                     (beginning-of-buffer)
                     (while (re-search-forward "/" nil t)
                       (replace-match "\\\\/"))
                     (beginning-of-buffer)
                     (while (re-search-forward "\""  nil t)
                       (replace-match "\\\\\""))
                     (beginning-of-buffer)
                     (insert-char ?\")
                     (end-of-buffer)
                     (insert ?\")))

                 )
       :bind (:map groovy-mode-map
                   ("C-c s" . stringify)
                   ("C-c S" . unstringify)))
   #+end_src

** Golang
   Installation is just download distribution and correct =PATH= and
   =GOPATH= environment variables.

   Some of the helpful tools to install
   - =goimports= To automatically resolve imports and formatting
     =go get golang.org/x/tools/cmd/goimports=
   - =gocode=  For autocompletion and eldoc functionality
     =go get github.com/nsf/gocode=
   - =godef= to navigate code/definitions
     =go get github.com/rogpeppe/godef=


   #+begin_src emacs-lisp
     (use-package go-mode
       :ensure t
       :init (progn
               (use-package go-eldoc
                 :ensure t
                 :init
                 (add-hook 'go-mode-hook 'go-eldoc-setup))
               (use-package company-go
                 :ensure t
                 :init
                 (add-hook 'go-mode-hook (lambda () (ffy-add-company-backends 'company-go))))

               (defun go-run-buffer ()
                 "This will run buffer on the Go"
                 (interactive)
                 (compile (concat "go run " (buffer-file-name))))

               (add-hook 'go-mode-hook (lambda ()
                                         ;; customize  compile command for go-mode
                                         (set (make-local-variable 'compile-command)
                                              "go build")
                                         ;; make before-save-hook local for go-mode buffer
                                         (add-hook 'before-save-hook 'gofmt nil t))))
       :config (progn
                 (setq gofmt-command "goimports")
                 (bind-key "C-c C-f" 'gofmt go-mode-map)
                 (bind-key "C-c ?"  'godoc-at-point go-mode-map)
                 (bind-key "C-c d" 'godoc go-mode-map)
                 (bind-key "C-c C-r" 'go-run-buffer go-mode-map)))
   #+end_src

   Other things to look at:
   - =go-oracle= ([[https://docs.google.com/document/d/1SLk36YRjjMgKqe490mSRzOPYEDe0Y_WQNRv-EiFYUyw/view][Documentation]]).

* Finally
  Load custom variables and faces from the customization file
  #+begin_src emacs-lisp
    (setq custom-file (concat *dotfiles-dir* "custom.el"))
    (load custom-file 'noerror)
  #+end_src

  Each workstation I work on has some specific details that are
  described in the file for that machine. They are stored in the
  machine specific folder =systems=. Loading machine specific settings:

  #+begin_src emacs-lisp
    (let ((system-specific-config (concat *system-specific* system-name ".el")))
      (if (file-exists-p system-specific-config)
          (load system-specific-config)))
  #+end_src

  How long did it take to load?

  #+begin_src emacs-lisp
    (let ((elapsed (float-time (time-subtract (current-time)  *emacs-start-time*))))
      (message "Loading Emacs...done (%.3fs)" elapsed))
  #+end_src
